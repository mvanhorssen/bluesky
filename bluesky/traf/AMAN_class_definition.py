# AMAN_class_definition.py
from scenario_functions import *
from scenario_generator import AllFlights, var_predeparture_delay # AllFlights contains information on all flights to be simulated
import numpy as np
import copy as copy
from performanceA import *
import sys

class AMAN(Flights):
    def __init__(self,AllFlights,unique_runways):
        self.AllFlights=AllFlights # Modified during simulation
        
        self.Original_AllFlights=copy.deepcopy(AllFlights) # Original dataset used at start of simulation    

        self.TotnumberPopup=0 # Total number of popups
        
        self.whichIAFs=[] # For each individual aircraft, which IAF is used?
        self.whichRWYs=[] # For each individual aircraft, which RWY is used?
        
        self.CurrDirectDist_to_RWY=[] # Direct distance to RWY
        self.CurrDirectDist_to_APT=[] # Direct distance to APT
        
        self.TP_sw=[] # For each individual aircraft, trajectory prediction on?
        
        self.Prev_wpt_name=[] # Waypoint name of previous waypoint
        self.Next_wpt_name=[] # Waypoint name of next waypoint
        self.Prev_wpt_LAT=[] # LAT (previous waypoint)
        self.Prev_wpt_LON=[] # LON (previous waypoint)        
        self.Next_wpt_LAT=[] # LAT (next waypoint)
        self.Next_wpt_LON=[] # LON (next waypoint)
        
        self.CurrLAT=[] # Current LAT
        self.CurrLON=[] # Current LON       
        self.CurrTAS=[] # Current Speed (TAS in kts)
        
        self.CurrLoc=[] # Outside_TMA or TMA     
        self.Before_or_After_TOD=[] # Is the aircraft before or after TOD?
        
        self.CurrDirectDist_to_nextwpt=[] # Distance to next waypoint
        
        self.CurrFlplCAS_nextwpt=[] # CAS to next waypoint according to (revised) flight plan
        self.CurrFlplTAS_nextwpt=[] # TAS to next waypoint according to (revised) flight plan
        self.CurrFlTime_to_nextwpt=[] # Flying time to next waypoint        
        self.CurrEstTime_at_nextwpt=[] # Estimated time at next waypoint   
        
        self.CurrEstTime_at_IAF=[] # Estimated time at IAF
        self.CurrFlTime_to_IAF=[] # Flying time to IAF        
        self.CurrEstTime_at_RWY=[] # Estimated time at RWY
        self.CurrFlTime_to_RWY=[] # Flying time to RWY
        self.CurrEstTime_at_CBAS=[] # Estimated time at CBAS
        self.CurrFlTime_to_CBAS=[] # Flying time to CBAS
        
        self.AMANhor_sw=[] # For each individual aircraft, taken into account by AMAN?
        
        self.CurrSchTime_at_IAF=[] # Scheduled time at IAF; -999 if not determined yet
        self.CurrSchTime_at_RWY=[] # Scheduled time at RWY; -999 if not determined yet
        self.CurrDelToBeAbs=[] # Total delay to be absorbed still prior to entering IAF; -999 if not determined yet
        self.STAstatus=[] # Status of STA (Variable, Semi-Fixed or Fixed)         
         
        self.SARA_sw=[] # For each individual aircraft, speed advisories generated by AMAN?          
        
        self.MinCAS_to_nextwpt=[] # Minimum CAS that can be flown to next waypoint
        self.MinTAS_to_nextwpt=[] # Minimum TAS that can be flown to next waypoint       
        self.MaxFT_to_nextwpt=[] # Maximum flying time to next waypoint
        self.MaxEstTime_at_nextwpt=[] # Latest possible estimated time at next waypoint (minimum speed)
        self.MaxEstTime_at_IAF=[] # Latest possible estimated time at IAF (minimum speed)
        self.MaxFT_to_IAF=[] # Maximum flying time to IAF (minimum speed)
        self.MaxEstTime_at_RWY=[] # Latest posible estimated time at RWY (minimum speed)
        self.MaxFT_to_RWY=[] # Maximum flying time to RWY (minimum speed)       
        self.MaxPossSpdDelAbs_to_nextwpt=[] # Maximum delay that can be absorbed to next waypoint by speed reduction
        self.MaxPossSpdDelAbs_to_IAF=[] # Maximum delay that can be absorbed to IAF (from current point) by speed reduction
        self.MaxPossSpdDelAbs_to_RWY=[] # Maximum delay that can be absorbed to RWY (from current point) by speed reduction
        self.ReqDelAbsStack=[] # Required delay absorption in stack (as not possible by speed reduction)
        
        # Assumption: not able to fly faster than nominal speed (max=nominal)
        self.MaxCAS_to_nextwpt=[] # Maximum (nominal) CAS that can be flown to next waypoint       
        self.MaxTAS_to_nextwpt=[] # Maximum (nominal) TAS that can be flown to next waypoint
        self.MinFT_to_nextwpt=[] # Minimum flying time to next waypoint: maximum (nominal) speed
        self.MinEstTime_at_nextwpt=[] # Earliest possible estimated time at next waypoint: maximum (nominal) speed
        self.MinEstTime_at_IAF=[] # Earliest possible estimated time at IAF: maximum (nominal) speed
        self.MinFT_to_IAF=[] # Minimum flying time to IAF: maximum (nominal) speed
        self.MinEstTime_at_RWY=[] # Earliest possible estimated time at RWY: maximum (nominal) speed
        self.MinFT_to_RWY=[] # Minimum flying time to RWY: maximum (nominal) speed
        self.MaxPossSpdAcc_to_nextwpt=[] # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to next waypoint
        self.MaxPossSpdAcc_to_IAF=[] # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to IAF
        self.MaxPossSpdAcc_to_RWY=[] # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to RWY
        
        self.FinalDelAbsStrat_sw=[] # Switch that records whether the final delay absorption method (dog leg, stack, two semicircles) has been selected
        
        self.PopupScheduled=[] # Switch that records if the pop-up flight has been scheduled already. 'None' by default, 'NO' for pop-up flights and 'YES' when scheduled
        
        self.IterationCounter=[] # Iteration counter
        
        self.EnergyCost=[] # Energy cost per aircraft
        
        self.out1=[] # Temporary values used by AMAN
        self.out2=[] # Temporary values used by AMAN
        self.out3=[] # Temporary values used by AMAN
        
        self.out10=[] # Temporary values used by AMAN
        self.out11=[] # Temporary values used by AMAN
        self.out12=[] # Temporary values used by AMAN      
        
        self.LOG_time_at_CBAS=[] # Logger: estimated time at CBAS
        self.LOG_time_CBAS_passed=[] # Logger: time at CBAS
        self.LOG_time_at_IAF=[] # Logger: time at IAF
        self.LOG_time_at_RWY=[] # Logger: time at RWY  
        self.LOG_accuracy_predepest_at_CBAS=[] # Logger: accuracy of pre-departure estimate
        self.LOG_accuracy_predepest_at_IAF=[] # Logger: accuracy of pre-departure estimate (switch OFF SARA)
        self.LOG_accuracy_predepest_at_RWY=[] # Logger: accuracy of pre-departure estimate (switch OFF SARA)
        self.LOG_CBAS_passed=[] # Logger: did aircraft pass by CBAS already
        self.LOG_IAF_passed=[] # Logger: did aircraft pass by IAF already
        self.LOG_RWY_passed=[] # Logger: did aircraft pass by RWY already        
        self.LOG_delivery_accuracy_at_IAF=[] # Logger: accuracy at IAF (scheduled<>actual time at IAF)

        self.LOG_schtimehist_schtime=[] # Logger: record scheduled time (at RWY) in framework of scheduled time history
        self.LOG_schtimehist_disttorwy=[] # Logger: record direct distance (to APT) in framework of scheduled time history
        self.LOG_schtimehist_flightphase=[] # Logger: record flight phase in framework of scheduled time history
        self.LOG_schtimehist_STAstatus=[] # Logger: record status of STA in framework of scheduled time history        
        self.LOG_schtimehist_simtime=[] # Logger: record corresponding simulation time        
        
        self.LOG_energycost=[] # Logger: energy needed for flying the aircraft

        self.LOG_lowlevel_delabs_time=[] # Logger: how many seconds should aircraft absorb prior to entering TMA low-level (dog leg, two semicircles, holding stacks)        
        self.LOG_lowlevel_delabs_dist=[] # Logger: how much distance [nm] should aircraft fly extra prior to entering TMA low-level (dog leg, two semicircles, holding stacks)
        self.LOG_lowlevel_delabs_type=[] # Logger: which type of delay absorption ('None','DogLeg','TwoSemiCircles' or 'HoldingStack')  
        self.LOG_lowlevel_delabs_IAF=[] # Logger: which IAF does delay absorption take place		
        self.LOG_lowlevel_delabs_simtime=[] # Logger: record corresponding simulation time
        
        self.LOG_seqhist_number=[] # Logger: record which number in sequence (at RWY) in framework of sequence history        
        self.LOG_seqhist_disttorwy=[] # Logger: record direct distance (to APT) in framework of sequence history 
        self.LOG_seqhist_flightphase=[] # Logger: record flight phase in framework of sequence history        
        self.LOG_seqhist_STAstatus=[] # Logger: record status of STA in framework of sequence history        
		
        self.LOG_speed_changes_before_TOD_per_1_kts=[] # Logger: log amount of speed changes before TOD per 1 kts
        self.LOG_speed_changes_after_TOD_per_1_kts=[] # Logger: log amount of speed changes after TOD per 1 kts
        self.LOG_speed_changes_before_TOD_per_5_kts=[] # Logger: log amount of speed changes before TOD per 5 kts
        self.LOG_speed_changes_after_TOD_per_5_kts=[] # Logger: log amount of speed changes after TOD per 5 kts
        self.LOG_speed_changes_per_1_kts=[] # Logger: log amount of speed changes per 1 knot
        self.LOG_speed_changes_per_5_kts=[] # Logger: log amount of speed changes per 5 knots
		
        self.LOG_traffic_bunches_ARTIP=[] # Logger: log amount of bunches flying to IAF ARTIP
        self.LOG_traffic_bunches_RIVER=[] # Logger: log amount of bunches flying to IAF RIVER
        self.LOG_traffic_bunches_SUGOL=[] # Logger: log amount of bunches flying to IAF SUGOL
        self.LOG_traffic_bunches_18C=[] # Logger: log amount of bunches flying to RWY 18C
        self.LOG_traffic_bunches_27=[] # Logger: log amount of bunches flying to RWY 27
		
        self.LOG_trafficbunchhist_esttime=[]
        self.LOG_trafficbunchhist_disttorwy=[]
        self.LOG_trafficbunchhist_STAstatus=[]
        self.LOG_trafficbunchhist_currdelay=[]
        self.LOG_trafficbunchhist_simtime=[]
        
        self.initialize_values(unique_runways) # Initialise all parameters
     
    def initialize_values(self,unique_runways):
        counter=0        
        
        for runway in unique_runways:
            self.out1.append(0.)
            self.out2.append(0.)
            self.out3.append(0.)
            
            self.out10.append([])
            self.out11.append([])
            self.out12.append([])
            
        for j in range(len(self.AllFlights.CallSign)):
            self.Original_AllFlights.Route_outside_TMA[j].estminFT=self.Original_AllFlights.Route_outside_TMA[j].estFT # Add attribute to Original_AllFlights: minimum flying time (maximum/nominal speed)
            
            self.CurrDirectDist_to_RWY = np.append(self.CurrDirectDist_to_RWY,self.AllFlights.Direct_inbetween_dist[j]) # Direct distance to RWY
            self.CurrDirectDist_to_APT = np.append(self.CurrDirectDist_to_APT,self.AllFlights.Direct_inbetween_dist[j]) # Direct distance to APT          
            
            self.whichIAFs.append(self.AllFlights.Route_outside_TMA[j].whichIAF) # Find which IAF is used
            self.whichRWYs.append(self.AllFlights.Route_outside_TMA[j].whichRWY) # Find which RWY is used
            
            self.TP_sw.append('OFF')  # For each individual aircraft, trajectory prediction on?
        
            self.Prev_wpt_name.append(self.AllFlights.Route_outside_TMA[j].waypoints[0]) # Waypoint name of previous waypoint; 'none' if next waypoint is departure airport
            self.Next_wpt_name.append(self.AllFlights.Route_outside_TMA[j].waypoints[0]) # Waypoint name of next waypoint; 'none' if previous waypoint is arrival airport
            self.Prev_wpt_LAT = np.append(self.Next_wpt_LAT,self.AllFlights.Route_outside_TMA[j].LAT[0]) # LAT (previous waypoint)
            self.Prev_wpt_LON = np.append(self.Next_wpt_LON,self.AllFlights.Route_outside_TMA[j].LON[0]) # LON (previous waypoint)        
            self.Next_wpt_LAT= np.append(self.Next_wpt_LAT,self.AllFlights.Route_outside_TMA[j].LAT[0]) # LAT (nex waypoint)
            self.Next_wpt_LON= np.append(self.Next_wpt_LON,self.AllFlights.Route_outside_TMA[j].LON[0]) # LON (next waypoint)
            
            self.CurrLAT = np.append(self.CurrLAT,self.Next_wpt_LAT) # Current LAT
            self.CurrLON = np.append(self.CurrLON,self.Next_wpt_LON) # Current LON       
            self.CurrTAS = np.append(self.CurrTAS,0.) # Current Speed (TAS in kts)
            
            self.CurrLoc.append('Outside')
            self.Before_or_After_TOD.append('Before') # Is the aircraft before or after TOD?
            
            self.CurrDirectDist_to_nextwpt = np.append(self.CurrDirectDist_to_nextwpt,0.) # Distance to next waypoint
            self.CurrFlplCAS_nextwpt = np.append(self.CurrFlplCAS_nextwpt,0.) # CAS to next waypoint according to (revised) flight plan
            self.CurrFlplTAS_nextwpt = np.append(self.CurrFlplTAS_nextwpt,0.) # TAS to next waypoint according to (revised) flight plan
            self.CurrFlTime_to_nextwpt = np.append(self.CurrFlTime_to_nextwpt,0.) # Flying time to next waypoint
            self.CurrEstTime_at_nextwpt = np.append(self.CurrEstTime_at_nextwpt,0.) # Estimated time at next waypoint   
            
            self.CurrEstTime_at_IAF = np.append(self.CurrEstTime_at_IAF,self.AllFlights.PreDepEstTime_at_IAF[j]) # Estimated time at IAF
            self.CurrFlTime_to_IAF = np.append(self.CurrFlTime_to_IAF,self.AllFlights.Route_outside_TMA[j].estFT_to_IAF[0]) # Flying time to IAF
            self.CurrEstTime_at_RWY = np.append(self.CurrEstTime_at_RWY,self.AllFlights.PreDepEstTime_at_RWY[j]) # Estimated time at RWY
            self.CurrFlTime_to_RWY = np.append(self.CurrFlTime_to_RWY,self.AllFlights.Route_outside_TMA[j].estFT_to_RWY[0]) # Flying time to RWY
            self.CurrEstTime_at_CBAS = np.append(self.CurrEstTime_at_CBAS,self.AllFlights.PreDepEstTime_at_CBAS[j]) # Estimated time at CBAS
            self.CurrFlTime_to_CBAS = np.append(self.CurrFlTime_to_CBAS,self.AllFlights.Route_outside_TMA[j].estFT_to_CBAS[0]) # Flying time to CBAS
            
            self.AMANhor_sw.append('OFF') # For each individual aircraft, taken into account by AMAN?
        
            self.CurrSchTime_at_IAF = np.append(self.CurrSchTime_at_IAF,-999.) # Scheduled time at IAF; -999 if not determined yet
            self.CurrSchTime_at_RWY = np.append(self.CurrSchTime_at_RWY,-999.) # Scheduled time at RWY; -999 if not determined yet
            self.CurrDelToBeAbs = np.append(self.CurrDelToBeAbs,-999.) # Total delay to be absorbed still prior to entering IAF; -999 if not determined yet
         
            self.STAstatus.append('OFF') # Status of STA (OFF, Variable, Semi-Fixed or Fixed)         
            
            self.SARA_sw.append('OFF') # For each individual aircraft, speed advisories generated by AMAN?          
        
            self.MinCAS_to_nextwpt = np.append(self.MinCAS_to_nextwpt,999.) # Minimum CAS that can be flown to next waypoint
            self.MinTAS_to_nextwpt = np.append(self.MinTAS_to_nextwpt,999.) # Minimum TAS that can be flown to next waypoint       
            self.MaxFT_to_nextwpt = np.append(self.MaxFT_to_nextwpt,0.) # Maximum flying time to next waypoint
            self.MaxEstTime_at_nextwpt = np.append(self.MaxEstTime_at_nextwpt,-999.) # Latest possible estimated time at next waypoint (minimum speed)
            self.MaxEstTime_at_IAF = np.append(self.MaxEstTime_at_IAF,-999.) # Latest possible estimated time at IAF (minimum speed)
            self.MaxFT_to_IAF = np.append(self.MaxFT_to_IAF,0.) # Maximum flying time to IAF (minimum speed)
            self.MaxEstTime_at_RWY = np.append(self.MaxEstTime_at_RWY,-999.) # Latest posible estimated time at RWY (minimum speed)
            self.MaxFT_to_RWY = np.append(self.MaxFT_to_RWY,0.) # Maximum flying time to IAF (minimum speed)
            
            self.MaxPossSpdDelAbs_to_nextwpt = np.append(self.MaxPossSpdDelAbs_to_nextwpt,0.) # Maximum delay that can be absorbed to next waypoint by speed reduction
            self.MaxPossSpdDelAbs_to_IAF = np.append(self.MaxPossSpdDelAbs_to_IAF,self.AllFlights.Route_outside_TMA[j].maxposs_spddelabs_to_IAF[0]) # Maximum delay that can be absorbed to IAF (from current point) by speed reduction
            self.MaxPossSpdDelAbs_to_RWY = np.append(self.MaxPossSpdDelAbs_to_RWY,self.AllFlights.Route_outside_TMA[j].maxposs_spddelabs_to_RWY[0]) # Maximum delay that can be absorbed to RWY (from current point) by speed reduction
            self.ReqDelAbsStack = np.append(self.ReqDelAbsStack,0.) # Required delay absorption in stack (as not possible by speed reduction)
        
            # Assumption: not able to fly faster than nominal speed (max=nominal)
            self.MaxCAS_to_nextwpt = np.append(self.MaxCAS_to_nextwpt,0.) # Maximum (nominal) CAS that can be flown to next waypoint       
            self.MaxTAS_to_nextwpt = np.append(self.MaxTAS_to_nextwpt,0.) # Maximum (nominal) TAS that can be flown to next waypoint
            self.MinFT_to_nextwpt = np.append(self.MinFT_to_nextwpt,0.) # Minimum flying time to next waypoint: maximum (nominal) speed
            self.MinEstTime_at_nextwpt = np.append(self.MinEstTime_at_nextwpt,0.) # Earliest possible estimated time at next waypoint: maximum (nominal) speed
            self.MinEstTime_at_IAF = np.append(self.MinEstTime_at_IAF,0.) # Earliest possible estimated time at IAF: maximum (nominal) speed
            self.MinFT_to_IAF = np.append(self.MinFT_to_IAF,0.) # Minimum flying time to IAF: maximum (nominal) speed
            self.MinEstTime_at_RWY = np.append(self.MinEstTime_at_RWY,0.) # Earliest possible estimated time at RWY: maximum (nominal) speed
            self.MinFT_to_RWY = np.append(self.MinFT_to_RWY,0.) # Minimum flying time to RWY: maximum (nominal) speed
            self.MaxPossSpdAcc_to_nextwpt = np.append(self.MaxPossSpdAcc_to_nextwpt,0.) # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to next waypoint
            self.MaxPossSpdAcc_to_IAF = np.append(self.MaxPossSpdAcc_to_IAF,0.) # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to IAF
            self.MaxPossSpdAcc_to_RWY = np.append(self.MaxPossSpdAcc_to_RWY,0.) # Maximum (negative) delay that can be absorbed by accelerating to maximum (nominal) speed: up to RWY
            
            self.FinalDelAbsStrat_sw.append('False') # Switch that records whether the final delay absorption method (dog leg, stack, two semicircles) has been selected
            
            self.PopupScheduled.append('None') # Switch that records if the pop-up flight has been scheduled already. 'None' by default, 'NO' for pop-up flights and 'YES' when scheduled
            
            self.IterationCounter=0 # Iteration counter
        
            self.EnergyCost = np.append(self.EnergyCost,0.) # Energy cost per aircraft 
            
            self.LOG_time_at_CBAS = np.append(self.LOG_time_at_CBAS,-999.) # Logger: estimated time at CBAS
            self.LOG_time_CBAS_passed = np.append(self.LOG_time_CBAS_passed,-999.) # Logger: time at CBAS
            self.LOG_CBAS_passed = np.append(self.LOG_CBAS_passed,False) # Logger: Did aircraft pass by CBAS already
            self.LOG_time_at_IAF = np.append(self.LOG_time_at_IAF,-999.) # Logger: time at IAF
            self.LOG_time_at_RWY = np.append(self.LOG_time_at_RWY,-999.)  # Logger: time at RWY    
            self.LOG_accuracy_predepest_at_CBAS = np.append(self.LOG_accuracy_predepest_at_CBAS,-999.) # Logger: accuracy of pre-departure estimate
            self.LOG_accuracy_predepest_at_IAF = np.append(self.LOG_accuracy_predepest_at_IAF,-999.) # Logger: accuracy of pre-departure estimate (switch OFF SARA)
            self.LOG_accuracy_predepest_at_RWY = np.append(self.LOG_accuracy_predepest_at_RWY,-999.) # Logger: accuracy of pre-departure estimate (switch OFF SARA)
            self.LOG_IAF_passed = np.append(self.LOG_IAF_passed,False) # Logger: did aircraft pass by IAF already
            self.LOG_RWY_passed = np.append(self.LOG_RWY_passed,False) # Logger: did aircraft pass by RWY already  
            self.LOG_delivery_accuracy_at_IAF = np.append(self.LOG_delivery_accuracy_at_IAF,-999.) # Logger: accuracy at IAF (scheduled<>actual time at IAF)
        
            self.LOG_schtimehist_schtime.append([]) # Logger: record scheduled time (at RWY) in framework of scheduled time history
            self.LOG_schtimehist_disttorwy.append([]) # Logger: record direct distance (to APT) in framework of scheduled time history
            self.LOG_schtimehist_flightphase.append([]) # Logger: record flight phase in framework of scheduled time history
            self.LOG_schtimehist_STAstatus.append([]) # Logger: record status of STA in framework of scheduled time history
            self.LOG_schtimehist_simtime.append([]) # Logger: record corresponding simulation time
        
            self.LOG_energycost = np.append(self.LOG_energycost,-999) # Logger: energy cost per aircraft
        
            self.LOG_lowlevel_delabs_time = np.append(self.LOG_lowlevel_delabs_time,-999.) # Logger: how many seconds should aircraft absorb prior to entering TMA low-level (dog leg, two semicircles, holding stacks)        
            self.LOG_lowlevel_delabs_dist = np.append(self.LOG_lowlevel_delabs_time,-999.)  # Logger: how much distance [nm] should aircraft fly extra prior to entering TMA low-level (dog leg, two semicircles, holding stacks)
            self.LOG_lowlevel_delabs_type.append('None') # Logger: which type of delay absorption ('None','DogLeg','TwoSemiCircles' or 'HoldingStack')
            self.LOG_lowlevel_delabs_IAF.append('') # Logger: which IAF does delay absorption take place	
            self.LOG_lowlevel_delabs_simtime.append(-999.) # Logger: record corresponding simulation time
			
            self.LOG_seqhist_number.append([]) # Logger: record which number in sequence (at RWY) in framework of sequence history        
            self.LOG_seqhist_disttorwy.append([]) # Logger: record direct distance (to APT) in framework of sequence history 
            self.LOG_seqhist_flightphase.append([]) # Logger: record flight phase in framework of sequence history        
            self.LOG_seqhist_STAstatus.append([]) # Logger: record status of STA in framework of sequence history      

            self.LOG_speed_changes_before_TOD_per_1_kts = np.append(self.LOG_speed_changes_before_TOD_per_1_kts,0.) # Logger: log amount of speed changes before TOD per 1 kts
            self.LOG_speed_changes_after_TOD_per_1_kts = np.append(self.LOG_speed_changes_after_TOD_per_1_kts,0.) # Logger: log amount of speed changes after TOD per 1 kts
            self.LOG_speed_changes_before_TOD_per_5_kts = np.append(self.LOG_speed_changes_before_TOD_per_5_kts,0.) # Logger: log amount of speed changes before TOD per 5 kts
            self.LOG_speed_changes_after_TOD_per_5_kts = np.append(self.LOG_speed_changes_after_TOD_per_5_kts,0.) # Logger: log amount of speed changes after TOD per 5 kts	
            self.LOG_speed_changes_per_1_kts = np.append(self.LOG_speed_changes_per_1_kts,0.) # Logger: log amount of speed changes per 1 kts
            self.LOG_speed_changes_per_5_kts = np.append(self.LOG_speed_changes_per_5_kts,0.) # Logger: log amount of speed changes per 5 kts
			
            self.LOG_trafficbunchhist_esttime.append([])
            self.LOG_trafficbunchhist_disttorwy.append([])
            self.LOG_trafficbunchhist_STAstatus.append([])
            self.LOG_trafficbunchhist_currdelay.append([])
            self.LOG_trafficbunchhist_simtime.append([])
        
			# Count amount of popups
            if self.AllFlights.PopupLabel[j]=='POPUP':
                counter=counter+1
                self.PopupScheduled[-1]='NO'
        self.TotnumberPopup=counter
        del counter
    
    def update_TP(self,BS_CallSign,BS_LAT,BS_LON,BS_TAS,BS_LAT_nextwpt,BS_LON_nextwpt,BS_simtime): # Provided by BlueSky traffic: Aircraft CallSign/CurrentLAT,CurrentLON/ACTWPT
        # Calculates both with current flight plan (i.e. active in BlueSky), as well as if the aircraft would fly (or start flying) at the minimum/maximum speed over each leg
        simt=BS_simtime 
        counter=0      
                   
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            self.TP_sw[idx]='ON' # If aircraft is active in BS, switch on TP

            self.CurrLAT[idx]=BS_LAT[k] # Update current latitude in AMAN module
            self.CurrLON[idx]=BS_LON[k] # Update current longitude in AMAN module
            self.CurrTAS[idx]=BS_TAS[k] # Update current speed in AMAN module                    
            
			# Check if aircraft has passed CBAS
            self.CurrDirectDist_to_RWY[idx]=qdrdistA(float(self.CurrLAT[idx]),float(self.CurrLON[idx]),float(self.AllFlights.Route_TMA[idx].RWY_LAT),float(self.AllFlights.Route_TMA[idx].RWY_LON))
            self.CurrDirectDist_to_APT[idx]=qdrdistA(float(self.CurrLAT[idx]),float(self.CurrLON[idx]),float(self.AllFlights.Destination_LAT[idx]),float(self.AllFlights.Destination_LON[idx]))
            if self.CurrDirectDist_to_APT[idx] < 105. and self.LOG_time_CBAS_passed[idx] == -999. and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'ARTIP' and self.LOG_CBAS_passed[idx] == False:
				#print('Aircraft '+str(idx)+' has passed CBAS at '+str(simt)+' for IAF '+str(self.AllFlights.Route_outside_TMA[idx].whichIAF))
				self.LOG_CBAS_passed[idx] = True
				self.LOG_time_CBAS_passed[idx] = simt
            elif self.CurrDirectDist_to_APT[idx] < 85. and self.LOG_time_CBAS_passed[idx] == -999. and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'RIVER' and self.LOG_CBAS_passed[idx] == False:
				#print('Aircraft '+str(idx)+' has passed CBAS at '+str(simt)+' for IAF '+str(self.AllFlights.Route_outside_TMA[idx].whichIAF))
				self.LOG_CBAS_passed[idx] = True
				self.LOG_time_CBAS_passed[idx] = simt
            elif self.CurrDirectDist_to_APT[idx] < 93. and self.LOG_time_CBAS_passed[idx] == -999. and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'SUGOL' and self.LOG_CBAS_passed[idx] == False:
				#print('Aircraft '+str(idx)+' has passed CBAS at '+str(simt)+' for IAF '+str(self.AllFlights.Route_outside_TMA[idx].whichIAF))
				self.LOG_CBAS_passed[idx] = True
				self.LOG_time_CBAS_passed[idx] = simt
            
            self.Next_wpt_LAT[idx]=BS_LAT_nextwpt[k] # Traffic: BS_LAT=self.actwplat (vector)
            self.Next_wpt_LON[idx]=BS_LON_nextwpt[k] # Traffic: BS_LAT=self.actwplon (vector)

            # Find which waypoint this is in AMAN.AllFlights. Based on this, also deduce previous waypoint
            # Outside TMA?            
            for j in range(len(self.AllFlights.Route_outside_TMA[idx].waypoints)):            
                temp=qdrdistA(float(self.Next_wpt_LAT[idx]),float(self.Next_wpt_LON[idx]),float(self.AllFlights.Route_outside_TMA[idx].LAT[j]),float(self.AllFlights.Route_outside_TMA[idx].LON[j]))
                if temp<0.3:
                    self.Next_wpt_name[idx]=self.AllFlights.Route_outside_TMA[idx].waypoints[j] # Next waypoint name
                    
                    # Current flight plan speeds
                    self.CurrFlplCAS_nextwpt[idx]=self.AllFlights.Route_outside_TMA[idx].spd[j]
                    self.CurrFlplTAS_nextwpt[idx]=self.AllFlights.Route_outside_TMA[idx].spd_TAS[j]
					
                    # Minimum speeds
                    self.MinCAS_to_nextwpt[idx]=self.AllFlights.Route_outside_TMA[idx].minspd[j]
                    self.MinTAS_to_nextwpt[idx]=self.AllFlights.Route_outside_TMA[idx].minspd_TAS[j]
                                        
                    # Maximum (nominal) speeds
                    self.MaxCAS_to_nextwpt[idx]=self.Original_AllFlights.Route_outside_TMA[idx].spd[j]
                    self.MaxTAS_to_nextwpt[idx]=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[j]

                    self.CurrLoc[idx]='Outside_TMA'
                    
                    if j==0:
                        self.Prev_wpt_name[idx]=self.Next_wpt_name[idx]
                        self.Prev_wpt_LAT[idx]=self.Next_wpt_LAT[idx]
                        self.Prev_wpt_LON[idx]=self.Next_wpt_LON[idx]
                    elif j>0:
                        self.Prev_wpt_name[idx]=self.AllFlights.Route_outside_TMA[idx].waypoints[j-1]
                        self.Prev_wpt_LAT[idx]=self.AllFlights.Route_outside_TMA[idx].LAT[j-1]
                        self.Prev_wpt_LON[idx]=self.AllFlights.Route_outside_TMA[idx].LON[j-1]
                        
                        if self.AllFlights.Route_outside_TMA[idx].loc[j-1]=='BeforeTOD':
                            self.Before_or_After_TOD[idx]='Before' # Is the aircraft before or after TOD?
                        elif self.AllFlights.Route_outside_TMA[idx].loc[j-1]!='BeforeTOD':
                            self.Before_or_After_TOD[idx]='After' # Is the aircraft before or after TOD?
                    
            # In TMA?
            for j in range(len(self.AllFlights.Route_TMA[idx].waypoints)):            
                temp=qdrdistA(float(self.Next_wpt_LAT[idx]),float(self.Next_wpt_LON[idx]),float(self.AllFlights.Route_TMA[idx].LAT[j]),float(self.AllFlights.Route_TMA[idx].LON[j]))
                if temp<0.3:
                    self.Next_wpt_name[idx]=self.AllFlights.Route_TMA[idx].waypoints[j] # Next waypoint name
                    
                    # Current flight plan speeds
                    self.CurrFlplCAS_nextwpt[idx]=self.AllFlights.Route_TMA[idx].spd[j]
                    self.CurrFlplTAS_nextwpt[idx]=self.AllFlights.Route_TMA[idx].spd_TAS[j]                    
                    
                    # Minimum speeds
                    self.MinCAS_to_nextwpt[idx]=self.AllFlights.Route_TMA[idx].minspd[j]
                    self.MinTAS_to_nextwpt[idx]=self.AllFlights.Route_TMA[idx].minspd_TAS[j]
                    
                    # Maximum (nominal) speeds
                    self.MaxCAS_to_nextwpt[idx]=self.Original_AllFlights.Route_TMA[idx].spd[j]
                    self.MaxTAS_to_nextwpt[idx]=self.Original_AllFlights.Route_TMA[idx].spd_TAS[j]                      
                    
                    self.CurrLoc[idx]='TMA'      
                    self.Before_or_After_TOD[idx]='After' #Is the aircraft before or after TOD?      
                    
                    if self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].whichIAF:
                        self.CurrLoc[idx]='Outside_TMA'
                    
                    if j==0:
                        self.Prev_wpt_name[idx]=self.AllFlights.Route_outside_TMA[idx].waypoints[-1]
                        self.Prev_wpt_LAT[idx]=self.AllFlights.Route_outside_TMA[idx].LAT[-1]
                        self.Prev_wpt_LON[idx]=self.AllFlights.Route_outside_TMA[idx].LON[-1]
                    elif j>0:
                        self.Prev_wpt_name[idx]=self.AllFlights.Route_TMA[idx].waypoints[j-1]
                        self.Prev_wpt_LAT[idx]=self.AllFlights.Route_TMA[idx].LAT[j-1]
                        self.Prev_wpt_LON[idx]=self.AllFlights.Route_TMA[idx].LON[j-1]
                
            self.CurrDirectDist_to_nextwpt[idx]=qdrdistA(float(self.CurrLAT[idx]),float(self.CurrLON[idx]),float(self.Next_wpt_LAT[idx]),float(self.Next_wpt_LON[idx]))
            
            # Current flight plan speeds
            extratemp=((self.CurrFlplTAS_nextwpt[idx]-self.CurrTAS[idx])**2)/(self.CurrFlplTAS_nextwpt[idx]+self.CurrTAS[idx])
            extra=(+1)*(self.CurrFlplTAS_nextwpt[idx]>=self.CurrTAS[idx])*extratemp + (-1)*(self.CurrFlplTAS_nextwpt[idx]<=self.CurrTAS[idx])*extratemp           
            self.CurrFlTime_to_nextwpt[idx]=(self.CurrDirectDist_to_nextwpt[idx]/self.CurrFlplTAS_nextwpt[idx])*3600.+extra                   
            del extratemp,extra            
            self.CurrEstTime_at_nextwpt[idx]=simt+self.CurrFlTime_to_nextwpt[idx]
    
            # Minimum speeds
            extratemp=((self.MinTAS_to_nextwpt[idx]-self.CurrTAS[idx])**2)/(self.MinTAS_to_nextwpt[idx]+self.CurrTAS[idx])
            extra=(+1)*(self.MinTAS_to_nextwpt[idx]>=self.CurrTAS[idx])*extratemp + (-1)*(self.MinTAS_to_nextwpt[idx]<=self.CurrTAS[idx])*extratemp         
            self.MaxFT_to_nextwpt[idx]=(self.CurrDirectDist_to_nextwpt[idx]/self.MinTAS_to_nextwpt[idx])*3600.+extra            
            del extratemp,extra            
            self.MaxEstTime_at_nextwpt[idx]=simt+self.MaxFT_to_nextwpt[idx]           
                   
            # Maximum speeds
            extratemp=((self.MaxTAS_to_nextwpt[idx]-self.CurrTAS[idx])**2)/(self.MaxTAS_to_nextwpt[idx]+self.CurrTAS[idx])
            extra=(+1)*(self.MaxTAS_to_nextwpt[idx]>=self.CurrTAS[idx])*extratemp + (-1)*(self.MaxTAS_to_nextwpt[idx]<=self.CurrTAS[idx])*extratemp           
            self.MinFT_to_nextwpt[idx]=(self.CurrDirectDist_to_nextwpt[idx]/self.MaxTAS_to_nextwpt[idx])*3600.+extra
            del extratemp,extra            
            self.MinEstTime_at_nextwpt[idx]=simt+self.MinFT_to_nextwpt[idx]             
        
            # Flying time in TMA (Project assumption: no delay absorption in TMA > estimates of flying times in TMA do not change)
            TMA_transition_time=self.AllFlights.Route_TMA[idx].totestFT
            
            # Update flying times for each leg outside TMA
            for k in range(len(self.AllFlights.Route_outside_TMA[idx].waypoints)):
                if k==(len(self.AllFlights.Route_outside_TMA[idx].waypoints)-1): # Last waypoint outside TMA                             
                    # Current flight plan speeds (estimate)
                    extratemp=((self.AllFlights.Route_TMA[idx].spd_TAS[0]-self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])**2)/(self.AllFlights.Route_TMA[idx].spd_TAS[0]+self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])
                    extra=(+1)*(self.AllFlights.Route_TMA[idx].spd_TAS[0]>=self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp + (-1)*(self.AllFlights.Route_TMA[idx].spd_TAS[0]<=self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp                    
                    estimate=(self.AllFlights.Route_outside_TMA[idx].dist[k]/self.AllFlights.Route_TMA[idx].spd_TAS[0])*3600.+extra
                    del extratemp,extra
                    
                    # Minimum speeds (estimate2)
                    extratemp=((self.AllFlights.Route_TMA[idx].minspd_TAS[0]-self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])**2)/(self.AllFlights.Route_TMA[idx].minspd_TAS[0]+self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])
                    extra=(+1)*(self.AllFlights.Route_TMA[idx].minspd_TAS[0]>=self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])*extratemp + (-1)*(self.AllFlights.Route_TMA[idx].minspd_TAS[0]<=self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])*extratemp                    
                    estimate2=(self.AllFlights.Route_outside_TMA[idx].dist[k]/self.AllFlights.Route_TMA[idx].minspd_TAS[0])*3600.+extra
                    del extratemp,extra
                    
                    # Maximum speeds (estimate3)
                    extratemp=((self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]-self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])**2)/(self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]+self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])
                    extra=(+1)*(self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]>=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp + (-1)*(self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]<=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp                    
                    estimate3=(self.Original_AllFlights.Route_outside_TMA[idx].dist[k]/self.Original_AllFlights.Route_TMA[idx].spd_TAS[0])*3600.+extra
                    del extratemp,extra                    
                    
                else:
                    # Current flight plan speeds (estimate)
                    extratemp=((self.AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]-self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])**2)/(self.AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]+self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])
                    extra=(+1)*(self.AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]>=self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp + (-1)*(self.AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]<=self.AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp                 
                    estimate=(self.AllFlights.Route_outside_TMA[idx].dist[k]/self.AllFlights.Route_outside_TMA[idx].spd_TAS[k+1])*3600.+extra
                    del extratemp,extra
                
                    # Minimum speeds (estimate2)
                    extratemp=((self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k+1]-self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])**2)/(self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k+1]+self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])
                    extra=(+1)*(self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k+1]>=self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])*extratemp + (-1)*(self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k+1]<=self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k])*extratemp                 
                    estimate2=(self.AllFlights.Route_outside_TMA[idx].dist[k]/self.AllFlights.Route_outside_TMA[idx].minspd_TAS[k+1])*3600.+extra
                    del extratemp,extra               
                
                    # Maximum speeds (estimate3)
                    extratemp=((self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]-self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])**2)/(self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]+self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])
                    extra=(+1)*(self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]>=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp + (-1)*(self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k+1]<=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k])*extratemp                 
                    estimate3=(self.Original_AllFlights.Route_outside_TMA[idx].dist[k]/self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[k+1])*3600.+extra
                    del extratemp,extra                
                
                self.AllFlights.Route_outside_TMA[idx].estFT[k]=estimate
                self.AllFlights.Route_outside_TMA[idx].estmaxFT[k]=estimate2
                self.Original_AllFlights.Route_outside_TMA[idx].estminFT[k]=estimate3
            
			# Calculate estimate and flying time to CBAS
            for k in range(len(self.AllFlights.Route_outside_TMA[idx].waypoints)):
				if str(self.AllFlights.Route_outside_TMA[idx].waypoints[k] == 'WPT_CBAS') and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'ARTIP' and self.LOG_CBAS_passed[idx] == False:
					if str(self.Next_wpt_name[idx]) == 'ARTIP':
						break
					tempindex = self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])
					self.CurrFlTime_to_CBAS[idx] = self.CurrFlTime_to_nextwpt[idx]+np.sum(self.AllFlights.Route_outside_TMA[idx].estFT[tempindex:k])
					self.CurrEstTime_at_CBAS[idx] = simt+self.CurrFlTime_to_CBAS[idx]
				if str(self.AllFlights.Route_outside_TMA[idx].waypoints[k] == 'WPT_CBAS') and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'RIVER' and self.LOG_CBAS_passed[idx] == False:
					if str(self.Next_wpt_name[idx]) == 'RIVER':
						break
					tempindex = self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])
					self.CurrFlTime_to_CBAS[idx] = self.CurrFlTime_to_nextwpt[idx]+np.sum(self.AllFlights.Route_outside_TMA[idx].estFT[tempindex:k])
					self.CurrEstTime_at_CBAS[idx] = simt+self.CurrFlTime_to_CBAS[idx]
				if str(self.AllFlights.Route_outside_TMA[idx].waypoints[k] == 'WPT_CBAS') and str(self.AllFlights.Route_outside_TMA[idx].whichIAF) == 'SUGOL' and self.LOG_CBAS_passed[idx] == False:
					if str(self.Next_wpt_name[idx]) == 'SUGOL':
						break
					tempindex = self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])
					self.CurrFlTime_to_CBAS[idx] = self.CurrFlTime_to_nextwpt[idx]+np.sum(self.AllFlights.Route_outside_TMA[idx].estFT[tempindex:k])
					self.CurrEstTime_at_CBAS[idx] = simt+self.CurrFlTime_to_CBAS[idx]
			
            if self.CurrLoc[idx]=='TMA':
                self.CurrFlTime_to_IAF[idx]=-999.
                self.CurrEstTime_at_IAF[idx]=-999.
                self.CurrEstTime_at_IAF[idx]=self.CurrEstTime_at_IAF[idx]
                self.CurrEstTime_at_RWY[idx]=self.CurrEstTime_at_RWY[idx]
                
            elif self.CurrLoc[idx]=='Outside_TMA':
                if self.Next_wpt_name[idx] in self.AllFlights.Route_outside_TMA[idx].waypoints:
                    tempindex=self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])                                     
                    
                    # Current flight plan speeds                    
                    self.CurrFlTime_to_IAF[idx]=self.CurrFlTime_to_nextwpt[idx]+np.sum(self.AllFlights.Route_outside_TMA[idx].estFT[tempindex:])
                    # Minimum speeds
                    self.MaxFT_to_IAF[idx]=self.MaxFT_to_nextwpt[idx]+np.sum(self.AllFlights.Route_outside_TMA[idx].estmaxFT[tempindex:])
                    # Maximum speeds
                    self.MinFT_to_IAF[idx]=self.MinFT_to_nextwpt[idx]+np.sum(self.Original_AllFlights.Route_outside_TMA[idx].estminFT[tempindex:])                    
                    del tempindex                    
                    
                    # Current flight plan speeds                    
                    self.CurrFlTime_to_RWY[idx]=self.CurrFlTime_to_IAF[idx]+TMA_transition_time
                    self.CurrEstTime_at_IAF[idx]=simt+self.CurrFlTime_to_IAF[idx]
                    self.CurrEstTime_at_RWY[idx]=simt+self.CurrFlTime_to_RWY[idx]                    
                    # Minimum speeds
                    self.MaxFT_to_RWY[idx]=self.MaxFT_to_IAF[idx]+TMA_transition_time
                    self.MaxEstTime_at_IAF[idx]=simt+self.MaxFT_to_IAF[idx]
                    self.MaxEstTime_at_RWY[idx]=simt+self.MaxFT_to_RWY[idx]  
                    # Maximum speeds
                    self.MinFT_to_RWY[idx]=self.MinFT_to_IAF[idx]+TMA_transition_time
                    self.MinEstTime_at_IAF[idx]=simt+self.MinFT_to_IAF[idx]
                    self.MinEstTime_at_RWY[idx]=simt+self.MinFT_to_RWY[idx]
                    
                elif self.Next_wpt_name[idx] in self.AllFlights.Route_TMA[idx].waypoints:
                    # Current flight plan speeds                    
                    self.CurrFlTime_to_IAF[idx]=self.CurrFlTime_to_nextwpt[idx]
                    self.CurrEstTime_at_IAF[idx]=simt+self.CurrFlTime_to_IAF[idx]                   
                    self.CurrFlTime_to_RWY[idx]=self.CurrFlTime_to_IAF[idx]+TMA_transition_time
                    self.CurrEstTime_at_RWY[idx]=simt+self.CurrFlTime_to_RWY[idx]
                    # Minimum speeds
                    self.MaxFT_to_IAF[idx]=self.MaxFT_to_nextwpt[idx]
                    self.MaxEstTime_at_IAF[idx]=simt+self.MaxFT_to_IAF[idx]                   
                    self.MaxFT_to_RWY[idx]=self.MaxFT_to_IAF[idx]+TMA_transition_time
                    self.MaxEstTime_at_RWY[idx]=simt+self.MaxFT_to_RWY[idx] 
                    # Maximum speeds
                    self.MinFT_to_IAF[idx]=self.MinFT_to_nextwpt[idx]
                    self.MinEstTime_at_IAF[idx]=simt+self.MinFT_to_IAF[idx]
                    self.MinFT_to_RWY[idx]=self.MinFT_to_IAF[idx]+TMA_transition_time
                    self.MinEstTime_at_RWY[idx]=simt+self.MinFT_to_RWY[idx]
            
    def update_SARA(self,BS_CallSign,BS_Altitude,BS_Route,SARA_horizon,simtime,approach_margin): # BS_altitude in m
        for k in range(len(BS_CallSign)):
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.SARA_sw[idx]=='OFF' and self.CurrDirectDist_to_APT[idx] <= SARA_horizon:
                self.SARA_sw[idx]='ON'
				
            using_new_speeds = True
            
            # First case: Aircraft needs to absorb positive delays
            if self.SARA_sw[idx]=='ON' and self.CurrDelToBeAbs[idx]>approach_margin:
                # Only do this loop if delay to be absorbed is larger than approach margin.
                distance_to_almostIAF=qdrdistA(self.CurrLAT[idx],self.CurrLON[idx],float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LON))
                
                # Two possible situations dependent on the location of the aircraft: 
				# 1) Aircraft before almost IAF: speed reduction   
				# 2) Aircraft near almost IAF: decide on low-level absorption
				
                # Situation 1: Aircraft before almost IAF
                if (self.Next_wpt_name[idx] in self.AllFlights.Route_outside_TMA[idx].waypoints) and self.FinalDelAbsStrat_sw[idx]=='False': # Find active waypoint (outside TMA?)
                    wpt_index=self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])
					
                    self.MaxPossSpdDelAbs_to_nextwpt[idx]=self.MaxFT_to_nextwpt[idx]-self.CurrFlTime_to_nextwpt[idx] # Maximum delay that can be absorbed to next waypoint (from current point) by speed reduction
                    self.MaxPossSpdDelAbs_to_IAF[idx]=self.MaxFT_to_IAF[idx]-self.CurrFlTime_to_IAF[idx] # Maximum delay that can be absorbed to IAF (from current point) by speed reduction
					
					# Determine ratio for linear speed absorption throughout all legs
					# Limit ratio to 1: You cannot absorb more speed delays than what is possible!                
                    ratio=min(1.0,(self.CurrDelToBeAbs[idx]-approach_margin)/self.MaxPossSpdDelAbs_to_IAF[idx]) # Approach margin of delay does not have to be absorbed! 
                
                    for z in range(wpt_index,len(self.AllFlights.Route_outside_TMA[idx].waypoints)):
                        # First up to the next waypoint
                        if z==wpt_index and self.MaxPossSpdDelAbs_to_nextwpt[idx]>=1.: # Necessary to check that delay that can be absorbed is positive.
                            flyingtime_temp=max(0.,(ratio)*self.MaxPossSpdDelAbs_to_nextwpt[idx])+self.CurrFlTime_to_nextwpt[idx]
                            newTAS_temp=(self.CurrDirectDist_to_nextwpt[idx]/flyingtime_temp)*3600.
                            if using_new_speeds == True:
								alt = 0.5*(BS_Altitude[k]+float(self.AllFlights.Route_outside_TMA[idx].FL[z])*100*ft)
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
								del alt
                            else:
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),BS_Altitude[k]))
 
                            # Record speed change in logger
                            if self.Before_or_After_TOD[idx] == 'Before' and abs(self.LOG_speed_changes_per_1_kts[idx]-newCAS_temp) > 1:
								self.LOG_speed_changes_before_TOD_per_1_kts[idx] = self.LOG_speed_changes_before_TOD_per_1_kts[idx] + 1
								self.LOG_speed_changes_per_1_kts[idx] = newCAS_temp
                            elif self.Before_or_After_TOD[idx] == 'After' and abs(self.LOG_speed_changes_per_1_kts[idx]-newCAS_temp) > 1:
								self.LOG_speed_changes_after_TOD_per_1_kts[idx] = self.LOG_speed_changes_after_TOD_per_1_kts[idx] + 1
								self.LOG_speed_changes_per_1_kts[idx] = newCAS_temp
					
							# Record speed change in logger
                            if self.Before_or_After_TOD[idx] == 'Before' and abs(self.LOG_speed_changes_per_5_kts[idx]-newCAS_temp) > 5:
								self.LOG_speed_changes_before_TOD_per_5_kts[idx] = self.LOG_speed_changes_before_TOD_per_5_kts[idx] + 1
								self.LOG_speed_changes_per_5_kts[idx] = newCAS_temp
                            elif self.Before_or_After_TOD[idx] == 'After' and abs(self.LOG_speed_changes_per_5_kts[idx]-newCAS_temp) > 5:
								self.LOG_speed_changes_after_TOD_per_5_kts[idx] = self.LOG_speed_changes_after_TOD_per_5_kts[idx] + 1
								self.LOG_speed_changes_per_5_kts[idx] = newCAS_temp
							
							# Alter speed to next waypoint in object
                            self.AllFlights.Route_outside_TMA[idx].spd[z]=max(newCAS_temp,self.Original_AllFlights.Route_outside_TMA[idx].minspd[z]) # self.CurrFlplCAS_nextwpt[idx] will be using this value
                            self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]=max(newTAS_temp,self.Original_AllFlights.Route_outside_TMA[idx].minspd_TAS[z]) # self.CurrFlplTAS_nextwpt[idx] will be using this value
                            
                            del flyingtime_temp,newTAS_temp,newCAS_temp
							
                            # Of course, this is not yet communicated to traffic. This is done below
                            # First find the index of the waypoint being used by traffic
                            for d in range(len(BS_Route[k].wpname)):
                                temp=qdrdistA(self.Next_wpt_LAT[idx],self.Next_wpt_LON[idx],BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                                if temp<0.3:
                                    tempindex_BS=d
                                                
                                    BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[z]*kts # CAS [m/s]
									#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]*kts #TAS [m/s]
                            del temp,tempindex_BS  
                        
                        # Secondly also change speed in upcoming legs (up to IAF)
                        elif z>wpt_index:
                            leg_maxposs_spddel=self.AllFlights.Route_outside_TMA[idx].estmaxFT[z-1]-self.AllFlights.Route_outside_TMA[idx].estFT[z-1] # Maximum possible delay that can be absorbed by speed reduction
                            leg_delaytobeabs=max(0.,leg_maxposs_spddel*ratio) # Delay that should be absorbed
                            
                            # Conversion to CAS not straightforward. Intrapolate between minimum and nominal CAS/TAS values to find CAS for derived TAS value (per leg)                           
                            # (CAS1,TAS1) is minimum, (CAS2,TAS2) is nominal (maximum)
                            CAS1=self.Original_AllFlights.Route_outside_TMA[idx].minspd[z]
                            TAS1=self.Original_AllFlights.Route_outside_TMA[idx].minspd_TAS[z]
                            CAS2=self.Original_AllFlights.Route_outside_TMA[idx].spd[z]
                            TAS2=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[z]
                            
                            newTAS_temp=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]-ratio*(self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]-self.AllFlights.Route_outside_TMA[idx].minspd_TAS[z])
                            if using_new_speeds == True:
								alt = 0.5*(float(self.AllFlights.Route_outside_TMA[idx].FL[z-1])+float(self.AllFlights.Route_outside_TMA[idx].FL[z]))*100*ft
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
								del alt
                            else:
								if newTAS_temp!=TAS1:
									newCAS_temp=CAS1+((CAS2-CAS1)/(TAS2-TAS1))*(newTAS_temp-TAS1)
								elif newTAS_temp==TAS1:
									newCAS_temp=CAS1
							
                            # Alter speed to next waypoint in object
                            self.AllFlights.Route_outside_TMA[idx].spd[z]=max(newCAS_temp,self.Original_AllFlights.Route_outside_TMA[idx].minspd[z]) # self.CurrFlplCAS_nextwpt[idx] will be using this value
                            self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]=max(newTAS_temp,self.Original_AllFlights.Route_outside_TMA[idx].minspd_TAS[z]) # self.CurrFlplTAS_nextwpt[idx] will be using this value
                            del leg_maxposs_spddel,leg_delaytobeabs,newTAS_temp,newCAS_temp,CAS1,CAS2,TAS1,TAS2
                        
                            # Of course, this is not yet communicated to traffic. This is done below
                            # First find the index of the waypoint being used by traffic
                            for d in range(len(BS_Route[k].wpname)):
                                temp=qdrdistA(self.AllFlights.Route_outside_TMA[idx].LAT[z],self.AllFlights.Route_outside_TMA[idx].LON[z],BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                                if temp<0.2:
                                    tempindex_BS=d
                                    
                                    BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[z]*kts # CAS [m/s]
									#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]*kts #TAS [m/s]
                            del temp,tempindex_BS   
							
                    # Also change speed of first waypoint in TMA
                    leg_maxposs_spddel=self.AllFlights.Route_outside_TMA[idx].estmaxFT[-1]-self.AllFlights.Route_outside_TMA[idx].estFT[-1] # Maximum possible delay that can be absorbed by speed reduction
                    leg_delaytobeabs=max(0.,leg_maxposs_spddel*ratio) # Delay that should be absorbed
            
                    # Conversion to CAS not straightforward. Intrapolate between minimum and nominal CAS/TAS values to find CAS for derived TAS value (per leg)                           
                    # (CAS1,TAS1) is minimum, (CAS2,TAS2) is nominal (maximum)
                    CAS1=self.Original_AllFlights.Route_TMA[idx].minspd[0]
                    TAS1=self.Original_AllFlights.Route_TMA[idx].minspd_TAS[0]
                    CAS2=self.Original_AllFlights.Route_TMA[idx].spd[0]
                    TAS2=self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]
                    
                    newTAS_temp=self.AllFlights.Route_TMA[idx].spd_TAS[0]-ratio*(self.AllFlights.Route_TMA[idx].spd_TAS[0]-self.AllFlights.Route_TMA[idx].minspd_TAS[0])      
                    ## newTAS_temp = TAS2 - ratio*(TAS2-TAS1)
                    if using_new_speeds == True:
						alt = 0.5*(float(self.AllFlights.Route_outside_TMA[idx].FL[z])+float(self.AllFlights.Route_TMA[idx].FL[0]))*100*ft
						newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
						del alt
                    else:
						if newTAS_temp!=TAS1:
							newCAS_temp=CAS1+((CAS2-CAS1)/(TAS2-TAS1))*(newTAS_temp-TAS1)
							## newCAS_temp = vtas2cas(newTAS_temp,self.Original_AllFlights.Route_TMA[idx].FL[0]*100*ft)
						elif newTAS_temp==TAS1:
							newCAS_temp=CAS1
                
                    # Alter speed in object
                    self.AllFlights.Route_TMA[idx].spd[0]=max(newCAS_temp,self.Original_AllFlights.Route_TMA[idx].minspd[0])
                    self.AllFlights.Route_TMA[idx].spd_TAS[0]=max(newTAS_temp,self.Original_AllFlights.Route_TMA[idx].minspd_TAS[0])
                    del leg_maxposs_spddel,leg_delaytobeabs,newTAS_temp,newCAS_temp,CAS1,CAS2,TAS1,TAS2
                
                    # Of course, this is not yet communicated to traffic. This is done below
                    # First find the index of the waypoint being used by traffic
                    for d in range(len(BS_Route[k].wpname)):
                        temp=qdrdistA(float(self.AllFlights.Route_TMA[idx].LAT[0]),float(self.AllFlights.Route_TMA[idx].LON[0]),BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                        if temp<0.2:
                            tempindex_BS=d
                            
                            BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[0]*kts # CAS [m/s]
							#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_TMA[idx].spd_TAS[0]*kts #TAS [m/s]
                    del temp,tempindex_BS           
                            
                BS_Route[k].calcfp() # BlueSky flight plan is recalculated
                                
                # Situation 2: Aircraft near almost IAF: decide on low-level absorption
				
				# Three possible solutions dependent on the amount of delay and the IAF:
				# A) Dogleg: if delay is less than 50 seconds for IAF ARTIP and SUGOL or less than 150 seconds for IAF RIVER
				# B) Semicircles: if delay is more than 50 seconds and less than 150 seconds for IAF ARTIP and SUGOL
				# C) Holdings: if delay is more than 150 seconds for all IAFs
				
                S2A_1=self.AllFlights.Route_outside_TMA[idx].whichIAF != 'RIVER' and distance_to_almostIAF < 1. and self.CurrDelToBeAbs[idx]<=50. and self.FinalDelAbsStrat_sw[idx]=='False' and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF
                S2A_2 =self.AllFlights.Route_outside_TMA[idx].whichIAF == 'RIVER' and distance_to_almostIAF < 1. and self.CurrDelToBeAbs[idx]<=150. and self.FinalDelAbsStrat_sw[idx]=='False' and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF
             
                # Situation 2A: Dogleg
                if S2A_1 or S2A_2:
                    # Define dog leg                    
                    speed_flown_TAS=self.AllFlights.Route_TMA[idx].spd_TAS[0] # Same speed as to IAF
                    speed_flown_CAS=self.AllFlights.Route_TMA[idx].spd[0] # Same speed as to IAF
                    time_flown_extra_dogleg=max(30,self.CurrDelToBeAbs[idx]) # Determine extra flying time
                    distance_tobeflown_extra_dogleg=speed_flown_TAS*time_flown_extra_dogleg/3600.
                    
                    self.LOG_lowlevel_delabs_time[idx]=time_flown_extra_dogleg # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_dist[idx]=distance_tobeflown_extra_dogleg # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_type[idx]='DogLeg' # Logger: which type of delay absorption ('None','DogLeg','TwoSemiCircles' or 'HoldingStack')
                    self.LOG_lowlevel_delabs_IAF[idx]=self.AllFlights.Route_outside_TMA[idx].whichIAF
                    self.LOG_lowlevel_delabs_simtime[idx]=simtime                    
                    
                    A_LAT,A_LON,alpha=find_extraflying_waypoints_dogleg(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT,self.AllFlights.Route_outside_TMA[idx].almostIAF_LON,self.AllFlights.Route_outside_TMA[idx].IAF_LAT,self.AllFlights.Route_outside_TMA[idx].IAF_LON,distance_tobeflown_extra_dogleg,self.AllFlights.Route_TMA[idx].heading[0]) # nm, degrees                     
                    
                    # Find index of almostIAF:
                    for d in range(len(BS_Route[k].wpname)):
                        temp=qdrdistA(float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),self.AllFlights.Route_outside_TMA[idx].almostIAF_LON,BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                        if temp<0.2:
                            tempindex_BS=d
                
                    BS_Route[k].wpname.insert(tempindex_BS+1,'DogLeg')
                    BS_Route[k].wplat.insert(tempindex_BS+1,A_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+1,A_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+1,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+1,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+1,0)
                    BS_Route[k].wpflyby.insert(tempindex_BS+1,True) # Added
                    
                    self.FinalDelAbsStrat_sw[idx]='True'
                    
                    BS_Route[k].calcfp() # BlueSky flight plan is recalculated                   
                    
                    del tempindex_BS,speed_flown_TAS,time_flown_extra_dogleg, distance_tobeflown_extra_dogleg,A_LAT,A_LON,alpha,temp,speed_flown_CAS
                
                # Situation 2B: Semicircles
                elif self.AllFlights.Route_outside_TMA[idx].whichIAF!='RIVER' and distance_to_almostIAF < 1. and self.CurrDelToBeAbs[idx]>50. and self.CurrDelToBeAbs[idx]<=150. and self.FinalDelAbsStrat_sw[idx]=='False' and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF:
                    speed_flown_TAS=self.AllFlights.Route_TMA[idx].spd_TAS[0] # Same speed as to IAF
                    speed_flown_CAS=self.AllFlights.Route_TMA[idx].spd[0] # Same speed as to IAF
                    time_flown_extra_semicircles=self.CurrDelToBeAbs[idx] # Variable delay between 50 and 150 seconds
                    distance_tobeflown_extra_twosemicircles=speed_flown_TAS*time_flown_extra_semicircles/3600.
                    
                    self.LOG_lowlevel_delabs_time[idx]=time_flown_extra_semicircles # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_dist[idx]=distance_tobeflown_extra_twosemicircles # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_type[idx]='TwoSemicircles' # Logger: which type of delay absorption ('None','DogLeg','TwoSemiCircles' or 'HoldingStack')   
                    self.LOG_lowlevel_delabs_IAF[idx]=self.AllFlights.Route_outside_TMA[idx].whichIAF					
                    self.LOG_lowlevel_delabs_simtime[idx]=simtime     
                    
                    A2_LAT,A2_LON,A3_LAT,A3_LON,B_LAT,B_LON,C1_LAT,C1_LON,C2_LAT,C2_LON,nominal_heading=find_extraflying_waypoints_semicircles(float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LON),float(self.AllFlights.Route_outside_TMA[idx].IAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].IAF_LON),distance_tobeflown_extra_twosemicircles,self.AllFlights.Route_TMA[idx].heading[0])
                    
                    # Find index of almostIAF:
                    for d in range(len(BS_Route[k].wpname)):
                        temp=qdrdistA(float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),self.AllFlights.Route_outside_TMA[idx].almostIAF_LON,BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                        if temp<0.2:
                            tempindex_BS=d
                    
                    BS_Route[k].wpname.insert(tempindex_BS+1,'TWOSEMICIRCLES1')
                    BS_Route[k].wplat.insert(tempindex_BS+1,A2_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+1,A2_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+1,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+1,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+1,0)                    
                    BS_Route[k].wpflyby.insert(tempindex_BS+1,True) # Added                    
                    
                    BS_Route[k].wpname.insert(tempindex_BS+2,'TWOSEMICIRCLES2')
                    BS_Route[k].wplat.insert(tempindex_BS+2,A3_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+2,A3_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+2,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+2,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+2,0)   
                    BS_Route[k].wpflyby.insert(tempindex_BS+2,True) # Added                         
                    
                    BS_Route[k].wpname.insert(tempindex_BS+3,'TWOSEMICIRCLES3')
                    BS_Route[k].wplat.insert(tempindex_BS+3,B_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+3,B_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+3,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+3,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+3,0)    
                    BS_Route[k].wpflyby.insert(tempindex_BS+3,True) # Added 
  
                    BS_Route[k].wpname.insert(tempindex_BS+4,'TWOSEMICIRCLES4')
                    BS_Route[k].wplat.insert(tempindex_BS+4,C1_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+4,C1_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+4,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+4,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+4,0)       
                    BS_Route[k].wpflyby.insert(tempindex_BS+4,True) # Added 
                    
                    BS_Route[k].wpname.insert(tempindex_BS+5,'TWOSEMICIRCLES5')
                    BS_Route[k].wplat.insert(tempindex_BS+5,C2_LAT)
                    BS_Route[k].wplon.insert(tempindex_BS+5,C2_LON)
                    BS_Route[k].wpalt.insert(tempindex_BS+5,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                    BS_Route[k].wpspd.insert(tempindex_BS+5,speed_flown_CAS*kts)
                    BS_Route[k].wptype.insert(tempindex_BS+5,0)   
                    BS_Route[k].wpflyby.insert(tempindex_BS+5,True) # Added                     
                    
                    self.FinalDelAbsStrat_sw[idx]='True'
					
                    BS_Route[k].calcfp() # BlueSky flight plan is recalculated
                
                    del speed_flown_TAS,time_flown_extra_semicircles,distance_tobeflown_extra_twosemicircles,temp,tempindex_BS,A2_LAT,A2_LON,A3_LAT,A3_LON,B_LAT,B_LON,C1_LAT,C1_LON,C2_LAT,C2_LON,nominal_heading,speed_flown_CAS
                
                # Situation 2C: Holdings
                elif distance_to_almostIAF < 1. and self.CurrDelToBeAbs[idx]>150. and self.FinalDelAbsStrat_sw[idx]=='False' and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF:
                    
                    speed_flown_TAS=self.AllFlights.Route_TMA[idx].spd_TAS[0] # Same speed as to IAF
                    speed_flown_CAS=self.AllFlights.Route_TMA[idx].spd[0] # Same speed as to IAF
                    time_flown_extra_holding=self.CurrDelToBeAbs[idx]
                    
					# Find amount of holdings (maximum holding time per holding is 300 seconds)
                    counter=1
                    while time_flown_extra_holding/counter > 300.:
                        counter=counter+1
                    
                    number_holdings=counter
                    time_flown_per_holding=time_flown_extra_holding/number_holdings
                    distance_flown_per_holding=speed_flown_TAS*time_flown_per_holding/3600.                    
                    
                    self.LOG_lowlevel_delabs_time[idx]=time_flown_extra_holding # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_dist[idx]=distance_flown_per_holding*number_holdings # Logger: record time and distance (low-level holding)                    
                    self.LOG_lowlevel_delabs_type[idx]='HoldingStack' # Logger: which type of delay absorption ('None','DogLeg','TwoSemiCircles' or 'HoldingStack')
                    self.LOG_lowlevel_delabs_IAF[idx]=self.AllFlights.Route_outside_TMA[idx].whichIAF
                    self.LOG_lowlevel_delabs_simtime[idx]=simtime     
                    
                    CenterLAT,CenterLON,R_Earth,heading_TMA,heading_perp=find_holdingstack_center(distance_flown_per_holding/(2.*np.pi),float(self.AllFlights.Route_outside_TMA[idx].IAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].IAF_LON),self.AllFlights.Route_TMA[idx].heading[0])
                    A_LAT,A_LON,B_LAT,B_LON,C_LAT,C_LON,D_LAT,D_LON=find_holdingstack_waypoints(distance_flown_per_holding/(2.*np.pi),CenterLAT,CenterLON,heading_TMA,heading_perp,R_Earth)
                    
                    # Find index of IAF:
                    for d in range(len(BS_Route[k].wpname)):
                        temp=qdrdistA(float(self.AllFlights.Route_outside_TMA[idx].IAF_LAT),self.AllFlights.Route_outside_TMA[idx].IAF_LON,BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                        if temp<0.2:
                            tempindex_BS=d
                    
                    for counter2 in range(number_holdings):
                        BS_Route[k].wpname.insert(tempindex_BS+counter2*4,'HOLDINGSTACKS1')
                        BS_Route[k].wplat.insert(tempindex_BS,D_LAT)
                        BS_Route[k].wplon.insert(tempindex_BS,D_LON)
                        BS_Route[k].wpalt.insert(tempindex_BS,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                        BS_Route[k].wpspd.insert(tempindex_BS,speed_flown_CAS*kts)
                        BS_Route[k].wptype.insert(tempindex_BS,0)   
                        BS_Route[k].wpflyby.insert(tempindex_BS,True) # Added 
                        
                        BS_Route[k].wpname.insert(tempindex_BS+1+counter2*4,'HOLDINGSTACKS2')
                        BS_Route[k].wplat.insert(tempindex_BS+1,A_LAT)
                        BS_Route[k].wplon.insert(tempindex_BS+1,A_LON)
                        BS_Route[k].wpalt.insert(tempindex_BS+1,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                        BS_Route[k].wpspd.insert(tempindex_BS+1,speed_flown_CAS*kts)
                        BS_Route[k].wptype.insert(tempindex_BS+1,0)       
                        BS_Route[k].wpflyby.insert(tempindex_BS+1,True) # Added 
    
                        BS_Route[k].wpname.insert(tempindex_BS+2+counter2*4,'HOLDINGSTACKS3')
                        BS_Route[k].wplat.insert(tempindex_BS+2,B_LAT)
                        BS_Route[k].wplon.insert(tempindex_BS+2,B_LON)
                        BS_Route[k].wpalt.insert(tempindex_BS+2,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                        BS_Route[k].wpspd.insert(tempindex_BS+2,speed_flown_CAS*kts)
                        BS_Route[k].wptype.insert(tempindex_BS+2,0)    
                        BS_Route[k].wpflyby.insert(tempindex_BS+2,True) # Added 
                    
                    
                        BS_Route[k].wpname.insert(tempindex_BS+3+counter2*4,'HOLDINGSTACKS4')
                        BS_Route[k].wplat.insert(tempindex_BS+3,C_LAT)
                        BS_Route[k].wplon.insert(tempindex_BS+3,C_LON)
                        BS_Route[k].wpalt.insert(tempindex_BS+3,float(self.AllFlights.Route_TMA[idx].FL[0])*100.*ft)
                        BS_Route[k].wpspd.insert(tempindex_BS+3,speed_flown_CAS*kts)
                        BS_Route[k].wptype.insert(tempindex_BS+3,0)    
                        BS_Route[k].wpflyby.insert(tempindex_BS+3,True) # Added 
                    
                    self.FinalDelAbsStrat_sw[idx]='True'
					
                    BS_Route[k].calcfp() # BlueSky flight plan is recalculated  
            
                    del speed_flown_TAS,time_flown_extra_holding,temp,tempindex_BS,speed_flown_CAS
                                
                del distance_to_almostIAF
                         
            # Second case: Aircraft needs to absorb negative delays (Aircraft needs to accelerate)
            if self.SARA_sw[idx]=='ON' and self.CurrDelToBeAbs[idx]<-approach_margin:
				# Only do this loop if delay to be absorbed is larger (in absolute terms) than approach margin
				
                # One situation: 
				# 1) Aircraft before almost IAF: speed increase
            
                # Situation 1: Aircraft before almost IAF
                if (self.Next_wpt_name[idx] in self.AllFlights.Route_outside_TMA[idx].waypoints) and self.FinalDelAbsStrat_sw[idx]=='False': # Find active waypoint (outside TMA?)
                    wpt_index=self.AllFlights.Route_outside_TMA[idx].waypoints.index(self.Next_wpt_name[idx])
                    
                    self.MaxPossSpdAcc_to_nextwpt[idx]=self.CurrFlTime_to_nextwpt[idx]-self.MinFT_to_nextwpt[idx] # Maximum delay that can be absorbed to next waypoint (from current point) by speed increase
                    self.MaxPossSpdAcc_to_IAF[idx]=self.CurrFlTime_to_IAF[idx]-self.MinFT_to_IAF[idx] # Maximum delay that can be absorbed to IAF (from current point) by speed increase
                    
					# Determine ratio for linear speed absorption throughout all legs
					# Limit ratio to 1: You cannot increase the speed than what is possible!    
                    ratio=min(1.0,(-self.CurrDelToBeAbs[idx]-approach_margin)/self.MaxPossSpdAcc_to_IAF[idx]) # Approach margin of delay does not have to be absorbed! 
                    ratio=max(0.,ratio)                                              
                    
                    for z in range(wpt_index,len(self.AllFlights.Route_outside_TMA[idx].waypoints)):
                        # First up to the next waypoint
                        if z==wpt_index and self.MaxPossSpdAcc_to_nextwpt[idx]>=1.: # Necessary to check that delay that can be absorbed is positive.
                            flyingtime_temp=max(0.,-(ratio)*self.MaxPossSpdAcc_to_nextwpt[idx])+self.CurrFlTime_to_nextwpt[idx]
                            newTAS_temp=(self.CurrDirectDist_to_nextwpt[idx]/flyingtime_temp)*3600.
                            if using_new_speeds == True:
								alt = 0.5*(BS_Altitude[k]+float(self.AllFlights.Route_outside_TMA[idx].FL[z])*100*ft)
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
								del alt
                            else:
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),BS_Altitude[k]))
                        
                            # Record speed change in logger
                            if self.Before_or_After_TOD[idx] == 'Before' and abs(self.LOG_speed_changes_per_1_kts[idx]-newCAS_temp) > 1:
								self.LOG_speed_changes_before_TOD_per_1_kts[idx] = self.LOG_speed_changes_before_TOD_per_1_kts[idx] + 1
								self.LOG_speed_changes_per_1_kts[idx] = newCAS_temp
                            elif self.Before_or_After_TOD[idx] == 'After' and abs(self.LOG_speed_changes_per_1_kts[idx]-newCAS_temp) > 1:
								self.LOG_speed_changes_after_TOD_per_1_kts[idx] = self.LOG_speed_changes_after_TOD_per_1_kts[idx] + 1
								self.LOG_speed_changes_per_1_kts[idx] = newCAS_temp
					
							# Record speed change in logger
                            if self.Before_or_After_TOD[idx] == 'Before' and abs(self.LOG_speed_changes_per_5_kts[idx]-newCAS_temp) > 5:
								self.LOG_speed_changes_before_TOD_per_5_kts[idx] = self.LOG_speed_changes_before_TOD_per_5_kts[idx] + 1
								self.LOG_speed_changes_per_5_kts[idx] = newCAS_temp
                            elif self.Before_or_After_TOD[idx] == 'After' and abs(self.LOG_speed_changes_per_5_kts[idx]-newCAS_temp) > 5:
								self.LOG_speed_changes_after_TOD_per_5_kts[idx] = self.LOG_speed_changes_after_TOD_per_5_kts[idx] + 1
								self.LOG_speed_changes_per_5_kts[idx] = newCAS_temp
						
                            # Alter speed to next waypoint in object
                            self.AllFlights.Route_outside_TMA[idx].spd[z]=newCAS_temp # self.CurrFlplCAS_nextwpt[idx] will be using this value
                            self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]=newTAS_temp # self.CurrFlplTAS_nextwpt[idx] will be using this value
                            
                            del flyingtime_temp,newTAS_temp,newCAS_temp
                        
                            # Of course, this is not yet communicated to traffic. This is done below
                            # First find the index of the waypoint being used by traffic
                            for d in range(len(BS_Route[k].wpname)):
                                temp=qdrdistA(self.Next_wpt_LAT[idx],self.Next_wpt_LON[idx],BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                                if temp<0.3:
                                    tempindex_BS=d
                                            
                                    BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[z]*kts #CAS [m/s]
									#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]*kts #TAS [m/s]
                            del temp,tempindex_BS  
                
                        # Secondly also change speed in upcoming legs (up to IAF)
                        elif z>wpt_index:
                            leg_maxposs_spdacc=self.AllFlights.Route_outside_TMA[idx].estFT[z-1]-self.AllFlights.Route_outside_TMA[idx].estminFT[z-1] # Maximum possible (negative) delay that can be removed by increasing speed
                            
                            # Conversion to CAS not straightforward. Intrapolate between minimum and nominal CAS/TAS values to find CAS for derived TAS value (per leg)                           
                            # (CAS1,TAS1) is minimum, (CAS2,TAS2) is nominal (maximum)
                            CAS1=self.Original_AllFlights.Route_outside_TMA[idx].minspd[z]
                            TAS1=self.Original_AllFlights.Route_outside_TMA[idx].minspd_TAS[z]
                            CAS2=self.Original_AllFlights.Route_outside_TMA[idx].spd[z]
                            TAS2=self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[z]
                       
                            newTAS_temp=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]+ratio*(self.Original_AllFlights.Route_outside_TMA[idx].spd_TAS[z]-self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]) # Original_AllFlights holds nominal (maximum) speed
                            if using_new_speeds == True:
								alt = 0.5*(float(self.AllFlights.Route_outside_TMA[idx].FL[z-1])+float(self.AllFlights.Route_outside_TMA[idx].FL[z]))*100*ft
								newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
								del alt
                            else:
								if newTAS_temp!=TAS1:
									newCAS_temp=CAS1+((CAS2-CAS1)/(TAS2-TAS1))*(newTAS_temp-TAS1)
								elif newTAS_temp==TAS1:
									newCAS_temp=CAS1
                    
                            # Alter speed to next waypoint in object
                            self.AllFlights.Route_outside_TMA[idx].spd[z]=newCAS_temp # self.CurrFlplCAS_nextwpt[idx] will be using this value
                            self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]=newTAS_temp # self.CurrFlplTAS_nextwpt[idx] will be using this value
                            del leg_maxposs_spdacc,newTAS_temp,newCAS_temp,CAS1,CAS2,TAS1,TAS2
                    
                            # Of course, this is not yet communicated to traffic. This is done below
                            # First find the index of the waypoint being used by traffic
                            for d in range(len(BS_Route[k].wpname)):
                                temp=qdrdistA(self.AllFlights.Route_outside_TMA[idx].LAT[z],self.AllFlights.Route_outside_TMA[idx].LON[z],BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                                if temp<0.2:
                                    tempindex_BS=d
                                
                                    BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[z]*kts #CAS [m/s]
									#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd_TAS[z]*kts #TAS [m/s]
                            del temp,tempindex_BS   
                     
                    # Also change speed of first waypoint in TMA
                    leg_maxposs_spdacc=self.AllFlights.Route_outside_TMA[idx].estFT[-1]-self.AllFlights.Route_outside_TMA[idx].estminFT[-1] # Maximum possible (negative) delay that can be removed by acceleration
                    leg_delaytobeacc=max(0.,leg_maxposs_spdacc*ratio) # Delay that should be removed by accelerating
        
                    # Conversion to CAS not straightforward. Intrapolate between minimum and nominal CAS/TAS values to find CAS for derived TAS value (per leg)                           
                    # (CAS1,TAS1) is minimum, (CAS2,TAS2) is nominal (maximum)
                    CAS1=self.Original_AllFlights.Route_TMA[idx].minspd[0]
                    TAS1=self.Original_AllFlights.Route_TMA[idx].minspd_TAS[0]
                    CAS2=self.Original_AllFlights.Route_TMA[idx].spd[0]
                    TAS2=self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]
                 
                    newTAS_temp=self.AllFlights.Route_TMA[idx].spd_TAS[0]+ratio*(self.Original_AllFlights.Route_TMA[idx].spd_TAS[0]-self.AllFlights.Route_TMA[idx].spd_TAS[0])                            
                    if using_new_speeds == True:
						alt = 0.5*(float(self.AllFlights.Route_outside_TMA[idx].FL[z])+float(self.AllFlights.Route_TMA[idx].FL[0]))*100*ft
						newCAS_temp=mpers2kts(vtas2cas(kts2mpers(newTAS_temp),alt))
						del alt
                    else:
						if newTAS_temp!=TAS1:
							newCAS_temp=CAS1+((CAS2-CAS1)/(TAS2-TAS1))*(newTAS_temp-TAS1)
						elif newTAS_temp==TAS1:
							newCAS_temp=CAS1
					
                    # Alter speed in object
                    self.AllFlights.Route_TMA[idx].spd[0]=newCAS_temp 
                    self.AllFlights.Route_TMA[idx].spd_TAS[0]=newTAS_temp
                    del leg_maxposs_spdacc,leg_delaytobeacc,newTAS_temp,newCAS_temp,CAS1,CAS2,TAS1,TAS2
            
                    # Of course, this is not yet communicated to traffic. This is done below
                    # First find the index of the waypoint being used by traffic
                    for d in range(len(BS_Route[k].wpname)):
                        temp=qdrdistA(float(self.AllFlights.Route_TMA[idx].LAT[0]),float(self.AllFlights.Route_TMA[idx].LON[0]),BS_Route[k].wplat[d],BS_Route[k].wplon[d])
                        if temp<0.2:
                            tempindex_BS=d
                        
                            BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_outside_TMA[idx].spd[z]*kts # CAS [m/s]
							#BS_Route[k].wpspd[tempindex_BS]=self.AllFlights.Route_TMA[idx].spd_TAS[0]*kts #TAS [m/s]
                    del temp,tempindex_BS           
                        
                BS_Route[k].calcfp() # BlueSky flight plan is recalculated 

    def scheduler_ASAP_basic(self,BS_CallSign,AMAN_horizon,RWY,intarrtime_RWY,STA_Freeze_horizon,unique_runways): 
        # First check: are there 'new' aircraft?
        newac_counter,ETAs,ETAs_ordered,list_index,sorting_order=self.scheduler_ASAP_basic_subfunction_newac_findifandwhich(BS_CallSign,AMAN_horizon,RWY,STA_Freeze_horizon)
    
        tempindextemp=unique_runways.index(RWY)
        last_semifixed_ETA=self.out1[tempindextemp]
        last_semifixed_STA=self.out2[tempindextemp]
        last_fixed_STA=self.out3[tempindextemp]
        
		# No new aircraft within horizon
        if newac_counter==0:
            self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
            last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
            last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
            self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights 
            
		# New aircraft within horizon
        elif newac_counter>0: 
            for z in range(newac_counter):
                ETA_newac=ETAs_ordered[newac_counter-1-z]
                temp=sorting_order[newac_counter-1-z]
                idx_newac=list_index[temp]
                del temp
                
                # Situation B.1: Normal flight
                if ETA_newac>last_semifixed_ETA and self.CurrDirectDist_to_APT[idx_newac]>STA_Freeze_horizon:                 
                    self.STAstatus[idx_newac]='Variable'
                    
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights 
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights 
                    
                # Situation B.2: Overtaking flight
                elif  ETA_newac<last_semifixed_ETA and self.CurrDirectDist_to_APT[idx_newac]>STA_Freeze_horizon: 
                    self.STAstatus[idx_newac]='Semi-Fixed'
                                                        
                    last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_basic_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,ETA_newac,idx_newac,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights 
                    
                # Situation B.3: Pop-up flight
                elif self.CurrDirectDist_to_APT[idx_newac]<STA_Freeze_horizon:
                    self.STAstatus[idx_newac]='Semi-Fixed'
                    
                    last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_basic_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,ETA_newac,idx_newac,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_basic_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights 
        
		#self.scheduler_ASAP_basic_subfunction_print_schedule(BS_CallSign,RWY)
		
		self.out1[tempindextemp]=last_semifixed_ETA
        self.out2[tempindextemp]=last_semifixed_STA
        self.out3[tempindextemp]=last_fixed_STA
	
    def scheduler_ASAP_basic_subfunction_print_schedule(self,BS_CallSign,RWY):
        ETAs=[]
        list_index=[]
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.AMANhor_sw[idx]=='ON' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:   
                ETAs.append(self.CurrSchTime_at_RWY[idx])
                list_index.append(idx)
            
        if len(ETAs)>0:        
            sorting_order=np.argsort(ETAs)
            
            ETAs_ordered=ETAs
            ETAs_ordered.sort()
            
            for l in range(len(ETAs)):
                temp=sorting_order[l]
                idx=list_index[temp]
                del temp
            
                print self.AllFlights.CallSign[idx],self.CurrEstTime_at_IAF[idx],self.CurrSchTime_at_IAF[idx],self.CurrEstTime_at_RWY[idx],self.CurrSchTime_at_RWY[idx],self.CurrDelToBeAbs[idx], self.STAstatus[idx],self.CurrDirectDist_to_APT[idx],self.AllFlights.Route_outside_TMA[idx].whichRWY
        print

    def scheduler_ASAP_subfunction_update_status(self,BS_CallSign,RWY,STA_Freeze_horizon):            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                distance_to_almostIAF=qdrdistA(self.CurrLAT[idx],self.CurrLON[idx],float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LON))  	
                
                # Update STA status to 'Fixed' when aircraft approaches almostIAF
                if distance_to_almostIAF < 1. and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF and self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:      
                    self.STAstatus[idx]='Fixed'
                    
                if self.CurrDirectDist_to_APT[idx]<=STA_Freeze_horizon and self.STAstatus[idx]=='Variable' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='Semi-Fixed'

    def scheduler_ASAP_subfunction_find_last_fixed_STA(self,BS_CallSign,RWY):                    
            STAs_fixed=[]            
            last_fixed_STA=0.      
            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    STAs_fixed.append(self.CurrSchTime_at_RWY[idx])
                    last_fixed_STA=max(STAs_fixed)                

            STAs_fixed=[]
            last_fixed_STA2=last_fixed_STA            
            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Semi-Fixed' and self.CurrSchTime_at_RWY[idx]<=last_fixed_STA2 and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='Fixed'
                
                if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    STAs_fixed.append(self.CurrSchTime_at_RWY[idx])
                    last_fixed_STA=max(STAs_fixed)
                    
            return last_fixed_STA

    def scheduler_ASAP_basic_subfunction_find_last_semifixed_ETAs_STAs(self,BS_CallSign,RWY,last_fixed_STA): 
            STAs_semifixed=[]
            last_semifixed_STA=0.
            
            ETAs_semifixed=[]
            last_semifixed_ETA=0.
            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:                    
                    ETAs_semifixed.append(self.CurrEstTime_at_RWY[idx])
                    last_semifixed_ETA=max(ETAs_semifixed)
  
            ETAs_semifixed=[]
            
            last_semifixed_ETA2=last_semifixed_ETA
            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Variable' and self.CurrEstTime_at_RWY[idx]<=last_semifixed_ETA2 and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='Semi-Fixed'
                    
                if self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    STAs_semifixed.append(self.CurrSchTime_at_RWY[idx])
                    last_semifixed_STA=max(STAs_semifixed)
                    
                    ETAs_semifixed.append(self.CurrEstTime_at_RWY[idx])
                    last_semifixed_ETA=max(ETAs_semifixed)

            return last_semifixed_ETA,last_semifixed_STA                     

    def scheduler_ASAP_basic_subfunction_update_varschedule(self,BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA): 
        ETAs_variable=[]  
        ETAs_variable_ordered=[]
        list_index_variable=[]
        LAS=max(0,last_semifixed_STA)
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                     self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
             
            elif self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                     self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
                     
            elif self.AMANhor_sw[idx]=='ON' and self.STAstatus[idx]=='Variable' and  self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                ETAs_variable.append(self.CurrEstTime_at_RWY[idx])
                list_index_variable.append(idx)    
        
        if len(ETAs_variable)>0:
               sorting_order_variable=np.argsort(ETAs_variable)
               
               ETAs_variable_ordered=ETAs_variable
               ETAs_variable_ordered.sort()
               
               for l in range(len(ETAs_variable_ordered)):
                 temp=sorting_order_variable[l]  
                 idx=list_index_variable[temp]
                 del temp
                 
                 scheduled_time_RWY=max(ETAs_variable_ordered[l],LAS+intarrtime_RWY)           
                 TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
                   
                 self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
                 self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
                 self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF  
                 LAS=self.CurrSchTime_at_RWY[idx]
                 
                 del scheduled_time_RWY,TMA_transition_time
                 
    def scheduler_ASAP_basic_subfunction_newac_findifandwhich(self,BS_CallSign,AMAN_horizon,RWY,STA_Freeze_horizon): 
        ETAs=[]
        list_index=[]
        
        newac_counter=0
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.AMANhor_sw[idx]=='OFF' and self.CurrDirectDist_to_APT[idx] <= AMAN_horizon and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.AMANhor_sw[idx]='ON'
                    newac_counter=newac_counter+1
                    
                    ETAs.append(self.CurrEstTime_at_RWY[idx])
                    list_index.append(idx)
        
        sorting_order=np.argsort(ETAs)        
        
        ETAs_ordered=ETAs
        ETAs_ordered.sort()
            
        return newac_counter,ETAs,ETAs_ordered,list_index,sorting_order
             
    def scheduler_ASAP_basic_subfunction_update_semifixed_using_ETAs(self,BS_CallSign,RWY,intarrtime_RWY,ETA_newac,idx_newac,last_fixed_STA):
        last_unaffected_STA=last_fixed_STA  
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            # Find last unaffected STA
            if idx!=idx_newac and self.CurrEstTime_at_RWY[idx]<ETA_newac and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                if self.STAstatus[idx]!='Fixed':                
                    self.STAstatus[idx]='Semi-Fixed'                 
                temp=self.CurrSchTime_at_RWY[idx]
                last_unaffected_STA=max(last_unaffected_STA,temp)
                del temp
            
        # Assign STA to new aircraft (= ETA or LAS + inter-arrival time)
        self.CurrSchTime_at_RWY[idx_newac]=max(ETA_newac,last_unaffected_STA+intarrtime_RWY)
        self.CurrSchTime_at_IAF[idx_newac]=self.CurrSchTime_at_RWY[idx_newac]-AllFlights.Route_TMA[idx_newac].totestFT
        self.CurrDelToBeAbs[idx_newac]=self.CurrSchTime_at_RWY[idx_newac]-self.CurrEstTime_at_RWY[idx_newac]        
        
        ETAs=[]        
        list_index=[]
        LAS=self.CurrSchTime_at_RWY[idx_newac]     
        last_semifixed_ETA=self.CurrEstTime_at_RWY[idx_newac]        
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if idx!=idx_newac and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.STAstatus[idx]=='Semi-Fixed' and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        if len(ETAs)==0:
            tempmaxETAs=self.CurrEstTime_at_RWY[idx_newac]         
        elif len(ETAs)>0:
            tempmaxETAs=max(ETAs)
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if idx!=idx_newac and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.CurrEstTime_at_RWY[idx]<tempmaxETAs and self.STAstatus[idx]=='Variable' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                self.STAstatus[idx]='Semi-Fixed'                
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        if len(ETAs)>0:
           sorting_order=np.argsort(ETAs)
           
           ETAs_ordered=ETAs
           ETAs_ordered.sort()
           
           for l in range(len(ETAs_ordered)):
             temp=sorting_order[l]  
             idx=list_index[temp]
             del temp
             
             scheduled_time_RWY=max(ETAs_ordered[l],LAS+intarrtime_RWY)           
             TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
               
             self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
             self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
             self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF  
             LAS=self.CurrSchTime_at_RWY[idx]
             last_semifixed_ETA=max(last_semifixed_ETA,self.CurrEstTime_at_RWY[idx])
             del scheduled_time_RWY,TMA_transition_time        
        
        last_semifixed_STA=LAS
        
        return last_semifixed_STA,last_semifixed_ETA
        
    def calculate_energy_cost_subfunction(self,RC,TAS,CD_0,CD_2,rho,S,phi,mass_nominal,delta_t): # SI UNITS! # phi=bank-angle and delta_t=time-step
        gamma=np.arcsin(RC/TAS)
        CL=2*mass_nominal*g0/(rho*S*np.cos(phi)*TAS**2)
        CD=CD_0+CD_2*CL**2    
        D=CD*1/2*rho*S*TAS**2
        T=D+mass_nominal*g0*np.sin(gamma)
        Power=T*TAS
        Energy=Power*delta_t
        
        return Energy
        
    def calculate_energy_cost(self,BS_CallSign,BS_RC,BS_TAS,CD0,CD2,BS_rho,WingSurface,BS_ahdg,BS_trk,mass_nominal,BS_deltat):
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            ahdg=BS_ahdg[k]
            trk=BS_trk[k]

            if ahdg<0:
                ahdg=ahdg+360.
            if trk<0:
                trk=trk+360.
            
            if abs(ahdg-trk)>2.:            
                phi=np.deg2rad(25.) # Set to bank angle of 25 degrees
            else:
                phi=0.
            
            RC=BS_RC[k]
            TAS=BS_TAS[k]
            rho=BS_rho[k]
                
            tempor=self.calculate_energy_cost_subfunction(RC,TAS,CD0,CD2,rho,WingSurface,phi,mass_nominal,BS_deltat)
            
            self.EnergyCost[idx]=self.EnergyCost[idx]+max(0,tempor)
            del tempor
                
    def scheduler_ASAP_upgrade(self,BS_CallSign,AMAN_horizon,RWY,intarrtime_RWY,STA_Freeze_horizon,unique_runways): 
        # First check: are there 'new' aircraft?
        normal_newac_counter,popup_newac_counter,ETAs_normal,ETAs_popup,list_index_normal,list_index_popup,sorting_order_normal,sorting_order_popup=self.scheduler_ASAP_upgrade_subfunction_newac_findifandwhich(BS_CallSign,AMAN_horizon,RWY,STA_Freeze_horizon)
    
        tempindextemp=unique_runways.index(RWY)
        
        ETA_popup_ground=self.out10[tempindextemp]
        CallSign_popup_ground=self.out12[tempindextemp]
       
        last_semifixed_ETA=self.out1[tempindextemp]
        last_semifixed_STA=self.out2[tempindextemp]
        last_fixed_STA=self.out3[tempindextemp]
        
        if normal_newac_counter==0 and popup_newac_counter==0:
            self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
            last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
            last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
            self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
        
		# Update new normal aircraft
        if normal_newac_counter>0:
            for z in range(normal_newac_counter):
                ETA_newac_normal=ETAs_normal[normal_newac_counter-1-z]
                tempor=sorting_order_normal[normal_newac_counter-1-z]
                idx_newac_normal=list_index_normal[tempor]
                del tempor
                
                # Situation B.1: Normal flight
                if ETA_newac_normal>last_semifixed_ETA and self.CurrDirectDist_to_APT[idx_newac_normal]>STA_Freeze_horizon:                 
                    self.STAstatus[idx_newac_normal]='Variable'
                    
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
               
                # Situation B.2: Overtaking flight
                elif  ETA_newac_normal<last_semifixed_ETA and self.CurrDirectDist_to_APT[idx_newac_normal]>STA_Freeze_horizon:                     
                    self.STAstatus[idx_newac_normal]='Semi-Fixed' 
                                                        
                    last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_upgrade_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,ETA_newac_normal,idx_newac_normal,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                   
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY)# Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                # Situation B.3: Pop-up flight
                elif self.CurrDirectDist_to_APT[idx_newac_normal]<STA_Freeze_horizon:
                    self.STAstatus[idx_newac_normal]='Semi-Fixed'
                    
                    last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_upgrade_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,ETA_newac_normal,idx_newac_normal,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights

		# Update new pop-up aircraft
        if popup_newac_counter>0: 
            for z in range(popup_newac_counter):
                ETA_newac_popup=ETAs_popup[popup_newac_counter-1-z]
                tempor=sorting_order_popup[popup_newac_counter-1-z]
                idx_newac_popup=list_index_popup[tempor]
                del tempor
                
                # Two situations possible: 
				# 1) Actual takeoff time > planned 
				# 2) Actual takeoff <= planned
				
                # Find out which situation
                CallSigntemp=AllFlights.CallSign[idx_newac_popup] # CallSign
                idx_in_initial_estimates=CallSign_popup_ground.index(CallSigntemp)
                initial_estimate_ETA=ETA_popup_ground[idx_in_initial_estimates]
                last_STA_as_popup_on_ground=self.CurrSchTime_at_RWY[idx_newac_popup]                
                
                swC1=self.CurrEstTime_at_RWY[idx_newac_popup]>initial_estimate_ETA
                swC2=self.CurrEstTime_at_RWY[idx_newac_popup]<=initial_estimate_ETA
                
                # Situation C.1: Aircraft takes off later. First insert pop-up flight, then re-schedule from gap onwards
                # Situation C.2: Aircraft takes off earlier. Similar two-step approach.
                if swC1 or swC2:
                    self.STAstatus[idx_newac_popup]='Semi-Fixed'
                    
                    # 1) First insert pop-up flight and re-schedule from there                                     
                    last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_upgrade_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,ETA_newac_popup,idx_newac_popup,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                                              
                    # 2) Then re-schedule from gap onwards
                    # This is not easy, because an earlier ETA does not necessarily imply an earlier STA in the semi-fixed phase
                    # Find aircraft with lowest ETA, but STA higher than the gap
                    # Re-insert that aircraft (using similar approach as for 'new' aircraft: see Situation B.3)
                    callsign_right_after_gap=[]
                    earliest_ETA=1E9                
                    
                    for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                        idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
                        if self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:                        
                            if self.CurrSchTime_at_RWY[idx]>last_STA_as_popup_on_ground:
                                earliest_ETA=min(earliest_ETA,self.CurrEstTime_at_RWY[idx])
                                if earliest_ETA==self.CurrEstTime_at_RWY[idx]:
                                    callsign_right_after_gap=self.AllFlights.CallSign[idx]
                                
                    for idx in range(len(self.AllFlights.CallSign)):
                        if self.STAstatus[idx]=='POPUP GRD SF' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                           if self.CurrSchTime_at_RWY[idx]>last_STA_as_popup_on_ground:
                                earliest_ETA=min(earliest_ETA,self.CurrEstTime_at_RWY[idx])
                                if earliest_ETA==self.CurrEstTime_at_RWY[idx]:
                                    callsign_right_after_gap=self.AllFlights.CallSign[idx]
                    
                    if callsign_right_after_gap!=[]:
                        temptempidx=self.AllFlights.CallSign.index(callsign_right_after_gap)
                        
                        last_semifixed_STA,last_semifixed_ETA=self.scheduler_ASAP_upgrade_subfunction_update_semifixed_using_ETAs(BS_CallSign,RWY,intarrtime_RWY,earliest_ETA,temptempidx,last_fixed_STA) # Update semi-fixed schedule with new aircraft
                        last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                        self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                        
                        del temptempidx
                
                    self.scheduler_ASAP_subfunction_update_status(BS_CallSign,RWY,STA_Freeze_horizon) # Update STA Status
                    last_fixed_STA=self.scheduler_ASAP_subfunction_find_last_fixed_STA(BS_CallSign,RWY) # Find last STA with status fixed and update status to fixed if current STA <= last STA
                    last_semifixed_ETA,last_semifixed_STA=self.scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(BS_CallSign,RWY,last_fixed_STA) # Find last ETA and STA with status semi-fixed and update status to semi-fixed if current ETA <= last ETA
                    self.scheduler_ASAP_upgrade_subfunction_update_varschedule(BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA) # Update current delay to be absorbed for status fixed and semi-fixed flights, and update ETA, STA, LAS and delay to be absorbed for status variable flights
                    
                del CallSigntemp,idx_in_initial_estimates,initial_estimate_ETA
				
        #self.scheduler_ASAP_upgrade_subfunction_print_schedule(BS_CallSign,RWY)
		
        self.out1[tempindextemp]=last_semifixed_ETA
        self.out2[tempindextemp]=last_semifixed_STA
        self.out3[tempindextemp]=last_fixed_STA
            
        del tempindextemp
             
    def initial_schedule_popupflightsonly(self,intarrtime_RWY,RWY,simulation_start,unique_runways): # In the scheduler, pop-up aircraft are already scheduled when still on ground. At initialisation of simulation, they are planned in already
                ETA_popup_ground_init=[]
                
                ETA_ordered_popup_ground_init=[]
                STA_ordered_popup_ground_init=[]
                index_popup_ground_init=[]  
                CallSign_ordered_popup_ground_init=[]
                
                for idx in range(len(self.AllFlights.CallSign)):
                    if self.AllFlights.PopupLabel[idx]=='POPUP' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                        ETA_popup_ground_init.append(self.AllFlights.PreDepEstTime_at_RWY[idx]-simulation_start)
                        index_popup_ground_init.append(idx)
                
                if len(ETA_popup_ground_init)>0:
                   sorting_order=np.argsort(ETA_popup_ground_init)
           
                   ETA_ordered_popup_ground_init=ETA_popup_ground_init
                   ETA_ordered_popup_ground_init.sort()
           
                   LAS=-1.
                   
                   for l in range(len(ETA_ordered_popup_ground_init)):
                     temp=sorting_order[l]  
                     idx=index_popup_ground_init[temp]
                     del temp
    
                     scheduled_time_RWY=max(ETA_ordered_popup_ground_init[l],LAS+intarrtime_RWY)  
                
                     TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
                     
                    # Here you can add a (random) error to the pre-departure estimate: negative error (delay) or positive error (earlier take-off)
                     if '--node' in sys.argv: # sys.argv[6] positive means that the pop-up flight departure is delayed
                        self.CurrEstTime_at_RWY[idx]=(self.AllFlights.PreDepEstTime_at_RWY[idx]-simulation_start)-float(var_predeparture_delay) # Need to substract the 'delay' in the pre-departure estimate.
                     else:    
                         self.CurrEstTime_at_RWY[idx]=self.AllFlights.PreDepEstTime_at_RWY[idx]-simulation_start                     
                    
                     self.CurrEstTime_at_IAF[idx]=self.CurrEstTime_at_RWY[idx]-TMA_transition_time                     
                     
                     self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
                     self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
                     self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF  
                     LAS=self.CurrSchTime_at_RWY[idx]
                     
                     STA_ordered_popup_ground_init.append(self.CurrSchTime_at_RWY[idx])
                     CallSign_ordered_popup_ground_init.append(self.AllFlights.CallSign[idx])

                     del scheduled_time_RWY,TMA_transition_time        

                     self.STAstatus[idx]='POPUP GRD VAR'

                tempor=unique_runways.index(RWY)                     
                self.out10[tempor]=ETA_ordered_popup_ground_init
                self.out11[tempor]=STA_ordered_popup_ground_init
                self.out12[tempor]=CallSign_ordered_popup_ground_init
                del tempor
                
    def scheduler_ASAP_upgrade_subfunction_newac_findifandwhich(self,BS_CallSign,AMAN_horizon,RWY,STA_Freeze_horizon): 
        ETAs_normal=[]
        ETAs_popup=[]
        
        ETAs_ordered_normal=[]
        ETAs_ordered_popup=[]
        
        list_index_normal=[]
        list_index_popup=[]
        
        normal_newac_counter=0
        popup_newac_counter=0
        
        sorting_order_normal=[]
        sorting_order_popup=[]
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.AMANhor_sw[idx]=='OFF' and self.CurrDirectDist_to_APT[idx] <= AMAN_horizon and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.AMANhor_sw[idx]='ON'
                    
                    if self.AllFlights.PopupLabel[idx]=='NORMAL':
                        normal_newac_counter=normal_newac_counter+1                    
                        ETAs_normal.append(self.CurrEstTime_at_RWY[idx])
                        list_index_normal.append(idx)
                        
                    elif self.AllFlights.PopupLabel[idx]=='POPUP':
                        popup_newac_counter=popup_newac_counter+1                    
                        ETAs_popup.append(self.CurrEstTime_at_RWY[idx])
                        list_index_popup.append(idx)
        
        if len(ETAs_normal)>0:        
            sorting_order_normal=np.argsort(ETAs_normal)               
            ETAs_ordered_normal=ETAs_normal
            ETAs_ordered_normal.sort()

        if len(ETAs_popup)>0:        
            sorting_order_popup=np.argsort(ETAs_popup)               
            ETAs_ordered_popup=ETAs_popup
            ETAs_ordered_popup.sort()           
        
        return normal_newac_counter,popup_newac_counter,ETAs_normal,ETAs_popup,list_index_normal,list_index_popup,sorting_order_normal,sorting_order_popup

    def scheduler_ASAP_upgrade_subfunction_update_varschedule(self,BS_CallSign,RWY,intarrtime_RWY,last_semifixed_STA): 
        ETAs_variable=[]  
        ETAs_variable_ordered=[]
        list_index_variable=[]
        LAS=max(0,last_semifixed_STA)
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                     self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
             
            elif self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                     self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
                     
            elif self.AMANhor_sw[idx]=='ON' and self.STAstatus[idx]=='Variable' and  self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                ETAs_variable.append(self.CurrEstTime_at_RWY[idx])
                list_index_variable.append(idx) 
                     
        for idx in range(len(self.AllFlights.CallSign)):
            if self.STAstatus[idx]=='POPUP GRD SF' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:            
                self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
                
            if self.STAstatus[idx]=='POPUP GRD VAR' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                ETAs_variable.append(self.CurrEstTime_at_RWY[idx])
                list_index_variable.append(idx)
        
        if len(ETAs_variable)>0:
               sorting_order_variable=np.argsort(ETAs_variable)
               
               ETAs_variable_ordered=ETAs_variable
               ETAs_variable_ordered.sort()
               
               for l in range(len(ETAs_variable_ordered)):
                 temp=sorting_order_variable[l]  
                 idx=list_index_variable[temp]
                 del temp
                 
                 scheduled_time_RWY=max(ETAs_variable_ordered[l],LAS+intarrtime_RWY)           
                 TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
                   
                 self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
                 self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
                 self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF  
                 LAS=self.CurrSchTime_at_RWY[idx]
                 
                 del scheduled_time_RWY,TMA_transition_time
				 
    def scheduler_ASAP_upgrade_subfunction_find_last_semifixed_ETAs_STAs(self,BS_CallSign,RWY,last_fixed_STA): 
            STAs_semifixed=[]
            last_semifixed_STA=0.
            
            ETAs_semifixed=[]
            last_semifixed_ETA=0.

            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:               
                    ETAs_semifixed.append(self.CurrEstTime_at_RWY[idx])
                    last_semifixed_ETA=max(ETAs_semifixed)
                    
            ETAs_semifixed=[]            
            last_semifixed_ETA2=last_semifixed_ETA
            
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Variable' and self.CurrEstTime_at_RWY[idx]<=last_semifixed_ETA2 and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='Semi-Fixed'
            
            for idx in range(len(self.AllFlights.CallSign)):
                if self.STAstatus[idx]=='POPUP GRD VAR' and self.CurrEstTime_at_RWY[idx]<=last_semifixed_ETA2 and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='POPUP GRD SF'
                
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                
                if self.STAstatus[idx]=='Semi-Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    STAs_semifixed.append(self.CurrSchTime_at_RWY[idx])
                    last_semifixed_STA=max(STAs_semifixed)
                    
                    ETAs_semifixed.append(self.CurrEstTime_at_RWY[idx])
                    last_semifixed_ETA=max(ETAs_semifixed)
                    
            for idx in range(len(self.AllFlights.CallSign)):
                if self.STAstatus[idx]=='POPUP GRD SF' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    STAs_semifixed.append(self.CurrSchTime_at_RWY[idx])
                    last_semifixed_STA=max(STAs_semifixed)
                    
                    ETAs_semifixed.append(self.CurrEstTime_at_RWY[idx])
                    last_semifixed_ETA=max(ETAs_semifixed)

            return last_semifixed_ETA,last_semifixed_STA      

    def scheduler_ASAP_upgrade_subfunction_update_semifixed_using_ETAs(self,BS_CallSign,RWY,intarrtime_RWY,ETA_newac,idx_newac,last_fixed_STA):
        last_unaffected_STA=last_fixed_STA  
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if idx!=idx_newac and self.CurrEstTime_at_RWY[idx]<ETA_newac and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                if self.STAstatus[idx]!='Fixed':                
                    self.STAstatus[idx]='Semi-Fixed'                 
                temp=self.CurrSchTime_at_RWY[idx]
                last_unaffected_STA=max(last_unaffected_STA,temp)
                del temp
         
        for idx in range(len(self.AllFlights.CallSign)):
            if self.STAstatus[idx]=='POPUP GRD SF' and self.CurrEstTime_at_RWY[idx]<ETA_newac and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY: 
                temp=self.CurrSchTime_at_RWY[idx]
                last_unaffected_STA=max(last_unaffected_STA,temp)
                del temp
        
        self.CurrSchTime_at_RWY[idx_newac]=max(ETA_newac,last_unaffected_STA+intarrtime_RWY)
        self.CurrSchTime_at_IAF[idx_newac]=self.CurrSchTime_at_RWY[idx_newac]-AllFlights.Route_TMA[idx_newac].totestFT
        self.CurrDelToBeAbs[idx_newac]=self.CurrSchTime_at_RWY[idx_newac]-self.CurrEstTime_at_RWY[idx_newac]        
        
        ETAs=[]        
        list_index=[]
        LAS=self.CurrSchTime_at_RWY[idx_newac]     
        last_semifixed_ETA=self.CurrEstTime_at_RWY[idx_newac]        
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if idx!=idx_newac and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.STAstatus[idx]=='Semi-Fixed' and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        for idx in range(len(self.AllFlights.CallSign)):
            if self.STAstatus[idx]=='POPUP GRD SF' and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        if len(ETAs)==0:
            tempmaxETAs=self.CurrEstTime_at_RWY[idx_newac]         
        elif len(ETAs)>0:
            tempmaxETAs=max(ETAs)
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if idx!=idx_newac and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.CurrEstTime_at_RWY[idx]<tempmaxETAs and self.STAstatus[idx]=='Variable' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                self.STAstatus[idx]='Semi-Fixed'                
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        for idx in range(len(self.AllFlights.CallSign)):
            if self.STAstatus[idx]=='POPUP GRD VAR' and self.CurrSchTime_at_RWY[idx]>last_unaffected_STA and self.CurrEstTime_at_RWY[idx]>=ETA_newac and self.CurrEstTime_at_RWY[idx]<tempmaxETAs and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                self.STAstatus[idx]='POPUP GRD SF'
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        if len(ETAs)>0:
           sorting_order=np.argsort(ETAs)
           
           ETAs_ordered=ETAs
           ETAs_ordered.sort()
           
           for l in range(len(ETAs_ordered)):
             temp=sorting_order[l]  
             idx=list_index[temp]
             del temp
             
             scheduled_time_RWY=max(ETAs_ordered[l],LAS+intarrtime_RWY)           
             TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
               
             self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
             self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
             self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF  
             LAS=self.CurrSchTime_at_RWY[idx]
             last_semifixed_ETA=max(last_semifixed_ETA,self.CurrEstTime_at_RWY[idx])
             del scheduled_time_RWY,TMA_transition_time        
        
        last_semifixed_STA=LAS
        
        return last_semifixed_STA,last_semifixed_ETA
	
    def scheduler_ASAP_upgrade_subfunction_print_schedule(BS_CallSign,RWY):
        ETAs=[]
        list_index=[]
        
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
            
            if self.AMANhor_sw[idx]=='ON' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:   
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
        
        for idx in range(len(self.AllFlights.CallSign)):   
            if self.STAstatus[idx] in ['POPUP GRD VAR','POPUP GRD SF'] and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                ETAs.append(self.CurrEstTime_at_RWY[idx])
                list_index.append(idx)
            
        if len(ETAs)>0:        
            sorting_order=np.argsort(ETAs)
            
            ETAs_ordered=ETAs
            ETAs_ordered.sort()
            
            for l in range(len(ETAs)):
                temp=sorting_order[l]
                idx=list_index[temp]
                del temp
            
                print self.AllFlights.CallSign[idx],self.CurrEstTime_at_IAF[idx],self.CurrSchTime_at_IAF[idx],self.CurrEstTime_at_RWY[idx],self.CurrSchTime_at_RWY[idx],self.CurrDelToBeAbs[idx], self.STAstatus[idx],self.CurrDirectDist_to_APT[idx],self.AllFlights.Route_outside_TMA[idx].whichRWY
        
        print
     
    def scheduler_dynamic(self,BS_CallSign,AMAN_horizon,RWY,intarrtime_RWY_nominal): 
         estimated_arrtimes_RWY_unordered=[]
         estimated_arrtimes_RWY_ordered=[]
         list_index=[]
         list_index2=[]
         
         fixed_STAs=[]
         last_fixed_STA=0.
         
         for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module

            distance_to_almostIAF=qdrdistA(self.CurrLAT[idx],self.CurrLON[idx],float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LAT),float(self.AllFlights.Route_outside_TMA[idx].almostIAF_LON))         
           
            if self.AMANhor_sw[idx]=='OFF' and self.CurrDirectDist_to_APT[idx] <= AMAN_horizon and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                self.AMANhor_sw[idx]='ON'
                self.STAstatus[idx]='Variable'
           
            if distance_to_almostIAF < 1. and self.Next_wpt_name[idx]==self.AllFlights.Route_outside_TMA[idx].almostIAF and self.STAstatus[idx]!='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:        
                self.STAstatus[idx]='Fixed'             
                
            if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                fixed_STAs.append(self.CurrSchTime_at_RWY[idx])
                last_fixed_STA=max(fixed_STAs)
          
         fixed_STAs=[] 
         
         for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
                           
                if self.STAstatus[idx]!='Fixed' and self.CurrSchTime_at_RWY[idx]<=last_fixed_STA and self.CurrSchTime_at_RWY[idx]>0 and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    self.STAstatus[idx]='Fixed'
                    
                if self.STAstatus[idx]=='Fixed' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY:
                    fixed_STAs.append(self.CurrSchTime_at_RWY[idx])
                    self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx]
                    list_index2.append(idx)
                        
                if self.AMANhor_sw[idx]=='ON' and self.AllFlights.Route_outside_TMA[idx].whichRWY==RWY and self.STAstatus[idx]!='Fixed':
                    estimated_arrtimes_RWY_unordered.append(self.CurrEstTime_at_RWY[idx])
                    list_index.append(idx)
					
         # For printing purposes only
         sorting_order_fixedSTAs=np.argsort(fixed_STAs)
         fixedSTAs_sorted=fixed_STAs
         fixedSTAs_sorted.sort()            
        
         for l in range(len(fixedSTAs_sorted)):
             temp=sorting_order_fixedSTAs[l]  
             idx=list_index2[temp]
             del temp
             #print self.AllFlights.CallSign[idx],self.CurrEstTime_at_IAF[idx],self.CurrSchTime_at_IAF[idx],self.CurrEstTime_at_RWY[idx],self.CurrSchTime_at_RWY[idx],self.CurrDelToBeAbs[idx],self.STAstatus[idx],self.CurrDirectDist_to_APT[idx],self.AllFlights.Route_outside_TMA[idx].whichRWY

         sorting_order=np.argsort(estimated_arrtimes_RWY_unordered)
                
         estimated_arrtimes_RWY_ordered=estimated_arrtimes_RWY_unordered
         estimated_arrtimes_RWY_ordered.sort()                 

         LAS=last_fixed_STA # IMPORTANT! last STA that is fixed is used for scheduling downstream flights
         
         for l in range(len(estimated_arrtimes_RWY_ordered)):
             temp=sorting_order[l]  
             idx=list_index[temp]
             del temp
			 
             # Revise inter-arrival time
             intarrtime_runway_revised=self.scheduler_dynamic_subfunction_find_intarrtime_basedon_popupratio(self.AllFlights.CallSign[idx],intarrtime_RWY_nominal)
             
             scheduled_time_RWY=max(estimated_arrtimes_RWY_ordered[l],LAS+intarrtime_runway_revised)

             TMA_transition_time=AllFlights.Route_TMA[idx].totestFT
               
             self.CurrSchTime_at_RWY[idx]=scheduled_time_RWY
             self.CurrSchTime_at_IAF[idx]=scheduled_time_RWY-TMA_transition_time
             self.CurrDelToBeAbs[idx]=self.CurrSchTime_at_RWY[idx]-self.CurrEstTime_at_RWY[idx] # How much delay is to be absorbed by each aircraft before/at IAF
    
             LAS=self.CurrSchTime_at_RWY[idx]
     
    def scheduler_dynamic_subfunction_find_intarrtime_basedon_popupratio(self,AircraftCallSign,Nominal_intarrtime): # For 1 aircraft, based on dataset relationship between distance<>pop-up ratio
        # Find aircraft in object
        idx_aircraft=self.AllFlights.CallSign.index(AircraftCallSign)
        
        # Direct distance to airport for aircraft considered
        distance_considered=self.CurrDirectDist_to_RWY[idx_aircraft]
    
        num_ac_below=sum(k<distance_considered for k in self.AllFlights.Direct_inbetween_dist)
        tot_num_ac=len(self.AllFlights.CallSign)
        
        PopupRatioLocal=float(num_ac_below)/float(tot_num_ac)
        PR=PopupRatioLocal*100.        
                
        tempor=min(3,1+(PR/(100-PR))) #limit to max 3 times nominal spacing          
        Revised_intarrtime=tempor*Nominal_intarrtime
        del tempor
        return Revised_intarrtime     
      
    def AMAN_LOG_arrtimes_and_energycost(self,BS_CallSign,simulation_start):   
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
           
                if self.CurrEstTime_at_IAF[idx]>-999.:
                    self.LOG_time_at_IAF[idx]=self.CurrEstTime_at_IAF[idx]
                    
                if self.CurrEstTime_at_RWY[idx]>-999.:
                    self.LOG_time_at_RWY[idx]=self.CurrEstTime_at_RWY[idx]
   
                if self.LOG_time_at_IAF[idx]>-999. and self.CurrEstTime_at_IAF[idx]==-999. and self.LOG_IAF_passed[idx]==False:
                    self.LOG_IAF_passed[idx]=True # Logger: did aircraft pass by IAF already
                    self.LOG_accuracy_predepest_at_IAF[idx]=self.LOG_time_at_IAF[idx]-(self.AllFlights.PreDepEstTime_at_IAF[idx]-simulation_start) # Logger: accuracy of pre-departure estimate (switch OFF SARA)
                    self.LOG_delivery_accuracy_at_IAF[idx]=self.LOG_time_at_IAF[idx]-self.CurrSchTime_at_IAF[idx] # Logger: accuracy at IAF (scheduled<>actual time at IAF); make sure that scheduler switched on
                    
            for idx in range(len(self.AllFlights.CallSign)):
                if self.LOG_time_at_RWY[idx]>-999. and self.LOG_RWY_passed[idx]==False and self.AllFlights.CallSign[idx] not in BS_CallSign:
                    self.LOG_RWY_passed[idx]=True # Logger: did aircraft pass by RWY already  
                    self.LOG_accuracy_predepest_at_RWY[idx]=self.LOG_time_at_RWY[idx]-(self.AllFlights.PreDepEstTime_at_RWY[idx]-simulation_start) # Logger: accuracy of pre-departure estimate (switch OFF SARA)
                    self.LOG_energycost[idx]=self.EnergyCost[idx]
                    
    def AMAN_LOG_STAhistory(self,BS_CallSign,simtime):
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
           
                if len(self.LOG_schtimehist_schtime[idx])>0:
                    if self.CurrSchTime_at_RWY[idx]!=self.LOG_schtimehist_schtime[idx][-1]:
                        self.LOG_schtimehist_schtime[idx].append(self.CurrSchTime_at_RWY[idx]) # Logger: record scheduled time (at RWY) in framework of scheduled time history
                        self.LOG_schtimehist_disttorwy[idx].append(self.CurrDirectDist_to_APT[idx]) # Logger: record direct distance (to APT) in framework of scheduled time history
                        self.LOG_schtimehist_flightphase[idx].append(self.Before_or_After_TOD[idx]) # Logger: record flight phase in framework of scheduled time history
                        self.LOG_schtimehist_STAstatus[idx].append(self.STAstatus[idx]) # Logger: record status of STA in framework of scheduled time history
                        self.LOG_schtimehist_simtime[idx].append(simtime) # Logger: record corresponding simulation time
                else: 
                        self.LOG_schtimehist_schtime[idx].append(self.CurrSchTime_at_RWY[idx]) # Logger: record scheduled time (at RWY) in framework of scheduled time history
                        self.LOG_schtimehist_disttorwy[idx].append(self.CurrDirectDist_to_APT[idx]) # Logger: record direct distance (to APT) in framework of scheduled time history
                        self.LOG_schtimehist_flightphase[idx].append(self.Before_or_After_TOD[idx]) # Logger: record flight phase in framework of scheduled time history
                        self.LOG_schtimehist_STAstatus[idx].append(self.STAstatus[idx]) # Logger: record status of STA in framework of scheduled time history
                        self.LOG_schtimehist_simtime[idx].append(simtime) # Logger: record corresponding simulation time
           
    def AMAN_LOG_seqhistory(self,BS_CallSign):
        for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
            idx=self.AllFlights.CallSign.index(BS_CallSign[k]) #Find index of element for AMAN module
  
            if self.CurrSchTime_at_RWY[idx]>0:
                tempsequence=1
                for z in range(len(self.AllFlights.CallSign)):
                        if self.CurrSchTime_at_RWY[z]<self.CurrSchTime_at_RWY[idx] and self.AllFlights.Route_outside_TMA[z].whichRWY==self.AllFlights.Route_outside_TMA[idx].whichRWY and self.CurrSchTime_at_RWY[z]>0:
                            tempsequence=tempsequence+1
                                  
                if len(self.LOG_seqhist_number[idx])>0:
                    if tempsequence!=self.LOG_seqhist_number[idx][-1]:                
                        self.LOG_seqhist_number[idx].append(tempsequence) # Logger: record which number in sequence (at RWY) in framework of sequence history        
                        self.LOG_seqhist_disttorwy[idx].append(self.CurrDirectDist_to_APT[idx]) # Logger: record direct distance (to APT) in framework of sequence history 
                        self.LOG_seqhist_flightphase[idx].append(self.Before_or_After_TOD[idx]) # Logger: record flight phase in framework of sequence history    
                        self.LOG_seqhist_STAstatus[idx].append(self.STAstatus[idx]) # Logger: record status of STA in framework of sequence history  
                        
                else:          
                    self.LOG_seqhist_number[idx].append(tempsequence) # Logger: record which number in sequence (at RWY) in framework of sequence history        
                    self.LOG_seqhist_disttorwy[idx].append(self.CurrDirectDist_to_APT[idx]) # Logger: record direct distance (to APT) in framework of sequence history 
                    self.LOG_seqhist_flightphase[idx].append(self.Before_or_After_TOD[idx]) # Logger: record flight phase in framework of sequence history    
                    self.LOG_seqhist_STAstatus[idx].append(self.STAstatus[idx]) # Logger: record status of STA in framework of sequence history  
                    
                del tempsequence
     
    def AMAN_LOG_lowleveldelay(self,BS_CallSign,simtime): # Set delay value from -999 to 0 when no low-level delay needed to be absorbed
         # Note that, in SARA, already the values for time and distance (low-level delay absorption) are recorded
         for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
           
                if self.CurrLoc[idx]=='TMA' and self.LOG_lowlevel_delabs_time[idx]<0.:
                    self.LOG_lowlevel_delabs_time[idx]=0.
                    self.LOG_lowlevel_delabs_dist[idx]=0.
                    self.LOG_lowlevel_delabs_IAF[idx]=self.AllFlights.Route_outside_TMA[idx].whichIAF
                    self.LOG_lowlevel_delabs_simtime[idx]=simtime
	
    def AMAN_LOG_CBAShistory(self,BS_CallSign,simulation_start):
		# Log CBAS time
		for k in range(len(BS_CallSign)):
			idx = self.AllFlights.CallSign.index(BS_CallSign[k])
			if self.CurrEstTime_at_CBAS[idx] > -999.:
				self.LOG_time_at_CBAS[idx] = self.CurrEstTime_at_CBAS[idx]
			
			if self.LOG_time_CBAS_passed[idx] > -999. and self.LOG_CBAS_passed[idx] == True:
				self.LOG_accuracy_predepest_at_CBAS[idx] = self.LOG_time_CBAS_passed[idx] - (self.AllFlights.PreDepEstTime_at_CBAS[idx]-simulation_start)
				
    def AMAN_LOG_traffic_bunches(self,BS_CallSign,approach_margin):
		counter_IAF_ARTIP = 0
		counter_IAF_RIVER = 0
		counter_IAF_SUGOL = 0
		counter_RWY_18C = 0
		counter_RWY_27 = 0
		for k in range(len(BS_CallSign)):
			idx = self.AllFlights.CallSign.index(BS_CallSign[k])
			for i in range(len(BS_CallSign)):
				idx_2 = self.AllFlights.CallSign.index(BS_CallSign[i])
				if (idx_2 != idx) and ((self.CurrEstTime_at_CBAS[idx_2]-self.CurrEstTime_at_CBAS[idx])<approach_margin) and ((self.CurrEstTime_at_CBAS[idx_2]-self.CurrEstTime_at_CBAS[idx])>0.) and (self.whichIAFs[idx_2] == self.whichIAFs[idx]) and self.LOG_CBAS_passed[idx_2] == False: # and ((self.CurrDelToBeAbs[idx_2]-self.MaxPossSpdDelAbs_to_IAF[idx_2])>approach_margin) 
					if str(self.whichIAFs[idx_2]) == 'ARTIP':
						counter_IAF_ARTIP = counter_IAF_ARTIP + 1
					if str(self.whichIAFs[idx_2]) == 'RIVER':
						counter_IAF_RIVER = counter_IAF_RIVER + 1
					if str(self.whichIAFs[idx_2]) == 'SUGOL':
						counter_IAF_SUGOL = counter_IAF_SUGOL + 1
				if (idx_2 != idx) and ((self.CurrEstTime_at_CBAS[idx_2]-self.CurrEstTime_at_CBAS[idx])<approach_margin) and ((self.CurrEstTime_at_CBAS[idx_2]-self.CurrEstTime_at_CBAS[idx])>0.) and self.LOG_CBAS_passed[idx_2] == False: # and ((self.CurrDelToBeAbs[idx_2]-self.MaxPossSpdDelAbs_to_IAF[idx_2])>approach_margin) 
					if str(self.whichRWYs[idx_2]) == '18C':
						counter_RWY_18C = counter_RWY_18C + 1
					if str(self.whichRWYs[idx_2]) == '27':
						counter_RWY_27 = counter_RWY_27 + 1
		self.LOG_traffic_bunches_ARTIP.append(counter_IAF_ARTIP)
		self.LOG_traffic_bunches_RIVER.append(counter_IAF_RIVER)
		self.LOG_traffic_bunches_SUGOL.append(counter_IAF_SUGOL)
		self.LOG_traffic_bunches_18C.append(counter_RWY_18C)
		self.LOG_traffic_bunches_27.append(counter_RWY_27)
		if counter_IAF_ARTIP>0 or counter_IAF_RIVER>0 or counter_IAF_SUGOL>0 or counter_RWY_18C>0 or counter_RWY_27>0:
			print(self.LOG_traffic_bunches_ARTIP[-1])
			print(self.LOG_traffic_bunches_RIVER[-1])
			print(self.LOG_traffic_bunches_SUGOL[-1])
			print(self.LOG_traffic_bunches_18C[-1])
			print(self.LOG_traffic_bunches_27[-1])

    def AMAN_LOG_ETA_CBAShistory(self,BS_CallSign,simtime):
            for k in range(len(BS_CallSign)): # Callsign is array from BlueSky traffic, implies that aircraft is airborne
                idx=self.AllFlights.CallSign.index(BS_CallSign[k]) # Find index of element for AMAN module
           
                if self.LOG_CBAS_passed[idx] is False:
                        self.LOG_trafficbunchhist_esttime[idx].append(self.CurrEstTime_at_CBAS[idx]) # Logger: record scheduled time (at RWY) in framework of scheduled time history
                        self.LOG_trafficbunchhist_disttorwy[idx].append(self.CurrDirectDist_to_APT[idx]) # Logger: record direct distance (to APT) in framework of scheduled time history
                        self.LOG_trafficbunchhist_STAstatus[idx].append(self.STAstatus[idx]) # Logger: record status of STA in framework of scheduled time history
                        self.LOG_trafficbunchhist_currdelay[idx].append(self.CurrDelToBeAbs[idx])
                        self.LOG_trafficbunchhist_simtime[idx].append(simtime) # Logger: record corresponding simulation time